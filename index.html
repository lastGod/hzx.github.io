<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="hzx&#39;s Home">
<meta property="og:url" content="https://hzxGoForward.github.io/index.html">
<meta property="og:site_name" content="hzx&#39;s Home">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hzx&#39;s Home">






  <link rel="canonical" href="https://hzxGoForward.github.io/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>hzx's Home</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hzx's Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Hello World！</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/04/15/Dash-研究资料/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/15/Dash-研究资料/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">Dash 研究资料</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-15 09:17:30 / 更新于：16:39:47" itemprop="dateCreated datePublished" datetime="2019-04-15T09:17:30+08:00">2019-04-15</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Dash学习资料"><a href="#Dash学习资料" class="headerlink" title="Dash学习资料"></a>Dash学习资料</h2><ul>
<li><p><a href="https://www.8btc.com/article/69654" target="_blank" rel="noopener">巴比特-达世币白皮书中文翻译</a></p>
</li>
<li><p><a href="https://docs.dash.org/zh_CN/latest/introduction/about.html" target="_blank" rel="noopener">达世币-中文帮助文档</a></p>
</li>
<li><p><a href="https://github.com/dashpay/dash/wiki/Whitepaper_zh_cn" target="_blank" rel="noopener">github-达世币白皮书</a></p>
</li>
<li><p><a href="https://docs.dash.org/zh_CN/stable/introduction/features.html#privatesend" target="_blank" rel="noopener">privateSend(匿名支付)</a></p>
</li>
<li><p><a href="https://github.com/dashpay/dash" target="_blank" rel="noopener">Dash github 源代码</a></p>
</li>
<li><p><a href="https://www.mycryptopedia.com/dash-privatesend/" target="_blank" rel="noopener">PrivateSend on MYCRYPTOPEDIA</a></p>
</li>
</ul>
<h2 id="Dash-匿名性分析"><a href="#Dash-匿名性分析" class="headerlink" title="Dash 匿名性分析"></a>Dash 匿名性分析</h2><ul>
<li><p><a href="https://bitcoinmagazine.com/articles/battle-privacycoins-why-dash-not-really-private/" target="_blank" rel="noopener">Battle of the Privacycoins: Why Dash Is Not Really That Private</a></p>
</li>
<li><p><a href="https://www.comparitech.com/crypto/anonymous-cryptocurrency-monerto-zcash/" target="_blank" rel="noopener">Monero vs Zcash vs Dash: which is the most anonymous cryptocurrency?</a></p>
</li>
</ul>
<h2 id="Dash’s-network"><a href="#Dash’s-network" class="headerlink" title="Dash’s network"></a>Dash’s network</h2><p>There are two main tiers in Dash, the miners and the master nodes. The Miners carry out similar functions to those in the bitcoin network. <strong>The master nodes are responsible for governance functions and for carrying out special transactions- InstantSend and PrivateSend.</strong></p>
<p><strong>InstantSend</strong> enables near-instantaneous transactions and is claimed to prevent double-spending, a potential problem with other cryptocurrencies. Regular block times are two and a half minutes whereas InstantSend transactions can be processed in under a second.</p>
<h2 id="PrivateSend"><a href="#PrivateSend" class="headerlink" title="PrivateSend"></a>PrivateSend</h2><p>PrivateSend is an implementation of <strong>CoinJoin</strong>. The privacy solution first proposed for Bitcoin by <a href="https://bitcoincore.org/" target="_blank" rel="noopener">Bitcoin Core</a> developer Gregory Maxwell. In PrivateSend, three users add their coins together in one big transaction, that sends the coins to freshly generated addresses belonging to the same three users. As such, the coins are effectively mixed between the three participants, breaking the blockchain trail of ownership between them. This process can be automatically repeated up to 16 times, with different mixing participants, for extra privacy. </p>
<p>The step of PrivateSend is following:</p>
<ol>
<li><p>Breakingdown a user’s transaction input into discrete denominations, with these denominations being: 0.01 DASH, 0.1 DASH, 1 DASH and 10 DASH.</p>
</li>
<li><p>A user’s Dash wallet will initiate a request to a Dash masternode, the masternode made aware that a user would like to mix a certain denomination of Dash coins. No identifiable information is sent to the masternodes, so they do not know who you are.</p>
</li>
<li><p>The masternode then issue a message to the network indicating that is ready to mix a denomination, and there is a users waiting.</p>
</li>
<li><p>Two other individuals who also wish to mix the same denomination of Dash coins can connect to the masternode that is hosting the other user’s transaction.</p>
</li>
<li><p>Start a mixing session, the masternode mixes up the inputs and instructs all three users’ wallets to pay the now-mixed input back to themselves.</p>
</li>
<li><p>A user’s wallet must repeat this mixing session multiple times(each time is called a round) to ensure that fund origins are fully anonymized.</p>
</li>
</ol>
<ul>
<li><p><strong>NOTE 1:</strong> Funds involved in the mixing process never leaves a user’s wallet, ensuring the entire process can remain trustless and secure.</p>
</li>
<li><p><strong>NOTE 2:</strong> Your wallet only contains 1000 of these “change addresses”. Every time a mixing event happens, one of your addresses is used up. Once enough of themn are used, your wallet must create more addresses. It can only do this, however, if you have automatic backups enabled. Consequently, users who have backups disabled will also have PrivateSend disabled.</p>
</li>
<li><p><a href="https://dashpay.atlassian.net/wiki/spaces/DOC/pages/1146924/PrivateSend" target="_blank" rel="noopener">PrivateSend 更多细节</a> *</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/04/10/An Empirical Analysis of Traceability in the Monero Blockchain/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/10/An Empirical Analysis of Traceability in the Monero Blockchain/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">An Empirical Analysis of Traceability in the Monero Blockchain</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-10 18:56:14 / 更新于：19:27:10" itemprop="dateCreated datePublished" datetime="2019-04-10T18:56:14+08:00">2019-04-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>This paper empirically evaluate <strong>two weakness</strong> in Monero’s mixin sampling strategy.</p>
<ul>
<li>About 62% of transaction inputs with one or more mixins are vulnerable to cascade effect so that the real input can be duduced by elimination</li>
<li>Monero mixins are sampled in a way that mixins can be easily distinguished form the real input by their age distribution. Since the real input is always the newest input.</li>
</ul>
<p>The author use the 2th weakness to guess real input with a 80% accuracy over all transactions with one or more mixins.</p>
<p>Besides, the author study the importance of mining pools and the former anonymous marketplace AlphaBay on the transaction volume. After removing mining pool activity, there remains a largte amount of potentially privacy-sensitive transactions that are affected by these weakness.</p>
<p>To improve the anonymity of Monero, the author gives two contermeasures.</p>
<ul>
<li>A new mixins sampling method with two-parameter model (gama distribution)is proposed which can well approximate the user’s ‘spend-time’ distribution.</li>
<li>Sampling mixins in ‘bins’, this method regardless of sampling distribution.</li>
</ul>
<h2 id="Deducible-Monero-Transactions"><a href="#Deducible-Monero-Transactions" class="headerlink" title="Deducible Monero Transactions"></a>Deducible Monero Transactions</h2><p>A significant number of Monero transactions do not contain any mixins at all, but instead explicityly identify the real TXO being spent. Since users are allowed to create zero-mixins transactions at the begining of Monero. These zero-mixins transaction present a hazard of deanonymization of transactions include them as mixins.</p>
<p>At the time of April 15, 2017, a total of 12158814 transaction inputs have zero mixins.Figure 5 presents the fraction of transactions containing zero-mixin inputs over time.<br><img src="https://img-blog.csdnimg.cn/2019041009332043.png" alt="在这里插入图片描述"></p>
<h3 id="implemention"><a href="#implemention" class="headerlink" title="implemention"></a>implemention</h3><p>The author extract Monero blackchain up to block 128774(April 15, 2017) and<br>stored it in a Neo4j graph database (11.5GB of data in total). the algorithm is the same as cascade effect(Amrit Kumar, Clément Fischer, Shruti Tople, and Prateek Saxena. A traceability analysis of Monero’s blockchain. In Simon N. Foley, Dieter Gollmann, and Einar Snekkenes, editors, Computer Security – ESORICS 2017: 22nd European Symposium on Research in Computer Security, Oslo, Norway, September 11-15, 2017, Proceedings, Part II, pages 153–173. Springer International Publishing, 2017.)</p>
<h3 id="Results-on-Deducible-Transactions"><a href="#Results-on-Deducible-Transactions" class="headerlink" title="Results on Deducible Transactions"></a>Results on Deducible Transactions</h3><p>Table 2 presents the results, totaly there are about 63% Monero transaction inputs with more than one mixins were deduced.</p>
<p><img src="https://img-blog.csdnimg.cn/20190410094354625.png" alt="在这里插入图片描述"><br>Figure 6 show the amount of vulnerable Monero transactions with the number of mixins, and it also shows transaction is less likely to be deducible with more mixins.<br><img src="https://img-blog.csdnimg.cn/20190410094947234.png" alt="在这里插入图片描述"></p>
<h2 id="Tracing-With-Temporal-Analysis"><a href="#Tracing-With-Temporal-Analysis" class="headerlink" title="Tracing With Temporal Analysis"></a>Tracing With Temporal Analysis</h2><h3 id="Effective-Untracebility"><a href="#Effective-Untracebility" class="headerlink" title="Effective-Untracebility"></a>Effective-Untracebility</h3><p>To quantify the untraceability of a transaction input, the authors used <strong>guessing entropy</strong> to represent the expected number of gusses before guessing the real spent among a inputs. The transaction input’s guessing entropy is defined as </p>
<script type="math/tex; mode=display">
\mathrm{Ge}=\sum_{0 \leq i \leq M} i \cdot p_{i}</script><p> where Ge is guessing entropy,  $p = p_0, p_1, . . . , p_M$ are probabilities, sorted highest to lowest, that a <strong>referenced output</strong> is the real spend of a transaction input.</p>
<p>The authors define <strong>effective-untraceability</strong> as $1+2Ge$.  if all referenced outputs of a transaction input are equally likely to be the real sepend, the effective-untraceabilty for that inputs is M+1.</p>
<h2 id="The-Guess-Newest-Heuristic"><a href="#The-Guess-Newest-Heuristic" class="headerlink" title="The Guess-Newest Heuristic"></a>The Guess-Newest Heuristic</h2><p>The author proposed a heustric that among all the prior outpus referenced by a Monero transaction input, the real spend is usually the newest one. That point view came from the Figure 2.<br><img src="https://img-blog.csdnimg.cn/2019041010321024.png" alt="在这里插入图片描述"><br>The conclusion came from zero-mixin inputs and inputs deduced from zero-mixin inputs. The mixin’s spending time is quite different with the real input.This is because users spend coins soon after receiving them while the mixin’s sampling method do not take account of user’s spending behaviours.</p>
<p>The authors found the 92% of the deducible inputs coule be gussed correctly in that way. The result is in Table 3.<br><img src="https://img-blog.csdnimg.cn/20190410110645176.png" alt="在这里插入图片描述"></p>
<h2 id="Countermeasures"><a href="#Countermeasures" class="headerlink" title="Countermeasures"></a>Countermeasures</h2><ol>
<li><strong>Improve the mixin-sampling procedure to match the real spend-time of MOnero users.</strong></li>
<li><strong>introduce a countermeasure called binned mixin sampling which modifies the current mixin sampling procedure.</strong></li>
</ol>
<h3 id="Estimating-the-spend-time-distribution"><a href="#Estimating-the-spend-time-distribution" class="headerlink" title="Estimating the spend-time distribution"></a>Estimating the spend-time distribution</h3><p>Following Figure shows the CDF of Bitcoin blockchain and Monero blockchain.<br><img src="https://img-blog.csdnimg.cn/20190410162056147.png" alt="在这里插入图片描述"><br>The Bitcoin spend-time have a somewhat similar shape with Monero spend-time.The authors use R’s fitdistr function to fit a gama distribution(shape parameter19.28, rate parameter 1.61)</p>
<h3 id="Sampling-mixins-using-the-spend-time-distribution"><a href="#Sampling-mixins-using-the-spend-time-distribution" class="headerlink" title="Sampling mixins using the spend-time distribution"></a>Sampling mixins using the spend-time distribution</h3><p>using the distribution above to sample mixins to matches the ideal spend-time. The author’s method is:</p>
<pre><code>1. sample a target timestamp directly from the distribution
2. Find the nearest block containing at least one RingCT output.
3. sample uniformly among the transaction outputs in that block
</code></pre><p>A more detail Algorithm is following<br><img src="https://img-blog.csdnimg.cn/20190410162826490.png" alt="在这里插入图片描述"></p>
<h3 id="Monte-Carlo-Simulation"><a href="#Monte-Carlo-Simulation" class="headerlink" title="Monte Carlo Simulation"></a>Monte Carlo Simulation</h3><p>Following Figure shows the effective untraceability set under the current regime and the author’s proposed mixin sampling routine, the effective-untraceability set has significant increased.method performs slightly worse than ideal at 6 and 12 months out, although still much better than the current method, and stays within 75% of the ideal<br><img src="https://img-blog.csdnimg.cn/20190410163723319.png" alt="在这里插入图片描述"></p>
<ul>
<li>Preserve some untraceability even in the face of a highly compromised mixin sampling distribution.</li>
</ul>
<h3 id="Binned-mixin-sampling"><a href="#Binned-mixin-sampling" class="headerlink" title="Binned mixin sampling"></a>Binned mixin sampling</h3><p>Group outputs in the Monero blockchain into sets of some fixed size called bins such that ecah output in a bin is confirmed in the same block or a neighboring block as Figure 13.</p>
<p><img src="https://img-blog.csdnimg.cn/20190410164656232.png" alt="在这里插入图片描述"><br>Any transaction input referencing a transaction output in a bin, either as a mixin or spend, must also reference all other outputs in that bin. Thus, a real spend cannot be distinguished by age from the other mixin outputs in the bin. Additionally, binned mixin sampling ensures that all the outputs in a bin cannot be deduced as spent until the last unspent output in the bin is spent, preventing deduction attacks from reducing the effectiveuntraceability of an output to less than the bin size.</p>
<p>Sample Algorithm is showed in Algorithm 2.<br><img src="https://img-blog.csdnimg.cn/20190410184941659.png" alt="在这里插入图片描述"></p>
<h2 id="Recommendations"><a href="#Recommendations" class="headerlink" title="Recommendations"></a>Recommendations</h2><ul>
<li>The mixing sampling distribution should be modified to closer match the real distribution.</li>
<li>Avoid including publicly deanonymized transaction outputs as mixins</li>
<li>Monero users should be warned that their prior transactions are likely vulnerable to tracing analysis<br>The aothor launched a block explorer(<a href="https://monerolink.com" target="_blank" rel="noopener">https://monerolink.com</a>), which displays the linkages between transactions infered using our techniques, they recommend additionally developing a wallet tool that users can run locally to determine wheter their previous transactions are vulnerable.</li>
</ul>
<h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>There is some points in this paper:</p>
<ul>
<li><p>Since zero-mixins result in a short transaction and spend less fees, so the user choose to choose zero-mixins, but the author ignores if it is because there are not enough same denominations?  But the paper [A Traceability Analysis of Monero’s Blockchain] (<a href="https://blog.csdn.net/t46414704152abc/article/details/89175204" target="_blank" rel="noopener">https://blog.csdn.net/t46414704152abc/article/details/89175204</a>) presents a rigorious analysis.</p>
</li>
<li><p>The author said new transactions are immune is not because of the RingCT mechanism itself, rater because RingCTs was deployed after the mandatory 2-mixin was enforced. I came up with a doublt, why? but the author didn’t tell us the analysis support.</p>
</li>
<li><p>May be next time, we should analyse the untraceability of RingCTs.</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/04/08/A Traceability Analysis of Monero’s Blockchain/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/08/A Traceability Analysis of Monero’s Blockchain/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">A Traceability Analysis of Monero’s Blockchain</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-08 22:30:00 / 更新于：22:36:52" itemprop="dateCreated datePublished" datetime="2019-04-08T22:30:00+08:00">2019-04-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>Monero 以相比于Bitcoin而言更加具有匿名性，在本文中作者使用了3中启发式的方法对Monero 区块链中的交易进行分析，虽然Monero中使用了mix-in方式，实际上其中87%的交易地址仍然是可以被追踪的；再新的Monero版本中采用了RingCTs，但是启发式方法仍然有效。在这些可以被追踪的交易中，其中98%的交易中使用的mix-in地址都是最近新产生的output地址，作者使用了Monero用户的消费习惯并对交易分析，实际分析结果表明Monero中以triangle distribution选择mix-in输入的方法对提升交易追踪难度作用不大。<br>    在对Monero进行分析之前，首先对Monero区块链进行了分析，其中发现如下3个重要信息：</p>
<ul>
<li>超过65%的交易输出，没有采用mix-in，也就是说这些交易本身是可追踪的。Monero中将可追踪的交易做mix-in，顺藤摸瓜可以追踪其他交易，作者以此65%为基础，顺藤摸瓜追踪到了另外22%的交易地址。</li>
<li>启发式方法二：一些minx-in中使用了某笔交易中的多个输出，这多个输出很有可能来自于同一人。以non-RingCTs的Monero区块链中87%的交易地址验证该启发式方法，真阳率为95%，鉴于此，推断出该方法仍然适用于RingCTs中的地址。</li>
<li>启发式方法三：Monero区块链中的UTXO，存在的时间越久，被花费的概率越大。仍然以non-RingCTs的Monero区块链中87%的交易地址验证该启发式方法，真阳率为98.5%，推断出该方法仍然适用于RingCTs区块链中。</li>
</ul>
<h2 id="Monero"><a href="#Monero" class="headerlink" title="Monero"></a>Monero</h2><p>Monero(XMR) 于2014年4月18日上线，当前出块时间为120秒，使用CryptoNote进行挖矿，每个区块奖励不定，，目前Monero价格为67美元。<br>    Monero提升用户匿名性上，使用了autonomous和spontaneous的协议，在Monero中用户在交易过程中可以自发的进行混币，混币本身并不增加额外的时间延迟。Monero主要解决了两个问题：</p>
<ul>
<li>（1）    Unlinkability，对于任意两笔交易，无法证明这两笔交易是转发给同一个人。</li>
<li>（2）    Untraceability，对于一笔交易中的输入，对应的赎回output应该隐藏在多个output中。</li>
</ul>
<p>对于Unlinkability，Monero中使用了one-time random address。每次进行交易时，发送方为接收方产生一个一次性的随机接收地址，而只有接收方才能花费接收地址中数字货币。这样的前提是每次产生接收地址时都有一个好的随机源，同时每个接收地址只使用一次。这就是Monero中的 <strong>Ring Signature</strong>。发送者（也是签名者）代表一组其他用户匿名签署交易（消息）。被赎回的实际输出在属于其他用户的选定输出集合中保持匿名。<br>2015年~2016年期间，Monero币价涨了将近27倍，到了2017年，Monero又采用了Ring Confidential Transaction(RingCTs)以提升其隐私性（隐藏交易真正的输出地址）。在RingCTs中隐藏了交易额。</p>
<h3 id="Monero-System-Parameter"><a href="#Monero-System-Parameter" class="headerlink" title="Monero System Parameter"></a>Monero System Parameter</h3><p>Monero中采用了Ed25519 椭圆加密算法,在该加密算法中。Monero中的每个用户都有一个长期的公钥对和私钥对，记为 $(pk_{LT}^{user}, sk_{LT}^{user})$，其中公钥对是可以公开的，公钥对用于接收转账，私钥对用于发送转账，它们关系如下：</p>
<ul>
<li>$sk_{LT}^{user} = (a, b)$， 范围是[1, L-1], L是椭圆曲线上某个点G的素数阶。</li>
<li>$pk_{LT}^{user} = (A, B)$, 其中A = aG， B= bG，其中<strong>G是标准的Ed25519基点</strong>。</li>
</ul>
<h3 id="Ensuring-Unlinkability"><a href="#Ensuring-Unlinkability" class="headerlink" title="Ensuring Unlinkability"></a>Ensuring Unlinkability</h3><p>Monero中发送方用接收方的公钥对随机产生一个一次性地址，然后将XMR发送至这个一次性地址，而只有接收方能够花费一次性地址中的XMR。假定发送方是Alice，接收方是Bob，Alice产生一次性地址的过程如下：</p>
<ul>
<li>获取Bob的$pk_{LT}^{Bob} = （A， B）$</li>
<li>随机产生一个r，r∈[1, L-1]</li>
<li>令R = rG， P = hash(rA)G+B</li>
<li>Bob的接收地址是P<br>由于P = hash(rA)G+B, 根据B的公钥对和私钥对的关系(A = aG, B = bG),同时R =rG，替换P的表达式，得到：</li>
<li><strong>P= hash(raG)G+bG = G(hash(aR)+b) = sG</strong></li>
</ul>
<p>而Alice转账给Bob的地址，Bob通过自己私钥中的(a, b)和R计算，因此只有Bob知道Alice环形签名中众多地址中真正转账给Bob的地址。<strong>在这笔转账中，除了Alice和Bob之外，没有人能知道真正转账给Bob的地址，这保证了Monero中交易的Unlinkability。</strong></p>
<p>如果需要多个output，可以随机出多个接收转账的地址，每个交易的输出只能被相应的一次性随即地址识别出来。在Monero中，每次转账的输出地址是一次性的公钥，记为$pk_{OT}$。对应的私钥记为${sk_OT}$，它们的关系记为P = sG。</p>
<h3 id="Ensuring-Untraceability"><a href="#Ensuring-Untraceability" class="headerlink" title="Ensuring Untraceability"></a>Ensuring Untraceability</h3><p>Monero中的不可追踪性是通过ring signatures(环形签名)实现的。环形签名使得用户可以在若干名用户形成的环上对消息进行签名。签名的用户只需要知道自己的私钥，签名后用户将其他用户的公钥放到环上。对于矿工或者接收方来说，他们只知道真正的签名者是环中的一员，但是无法确认是哪一个，发送方通过环签名的方法实现匿名。仍然以Alice 发送给Bob10 XMR为例说明环形签名的过程。</p>
<ul>
<li>Bob的$pk_{LT}^{Bob} = （A， B）$，然后随机产生发送地址P_Bob</li>
<li>Alice选取Monero链上其他一些价值为10 XMR的output$(P_1，P_2,…)$</li>
<li>令$S={\{P_1，P_2，…P_m\} }$,其中包括Alice自己的input $P_t = s_t G$</li>
</ul>
<p>Alice的input混合在其他价值为10的output中达到匿名的目的，而S称之为匿名集。Alcie使用自己的私钥s_t对消息进行签名。对于矿工和Bob来说，他们无法判断Alice这笔转账的支出来源地址，这就使得这笔转账的input具有了匿名性。S中其他用户的公钥称之为mix-ins，mix-ins越大，匿名性越好。</p>
<h3 id="Resist-Double-Spending"><a href="#Resist-Double-Spending" class="headerlink" title="Resist Double Spending"></a>Resist Double Spending</h3><p>上述Alice给Bob的转账中，既然无法确定Alice具体转账的input地址，对于矿工来说，无法知道Alice是否会进行double spending。为了解决该问题，Monero中引入了key image（ζ）机制，即Alice的交易中需要提供一个key image，即:</p>
<ul>
<li>$ζ = s_tHash_p (P_t)$</li>
</ul>
<p>上述哈希函数中会得到椭圆曲线中一个点，这有区别于Hash函数。key image 是对转账的input的一个可识别的标记，矿工会对每个区块中每笔交易的key image进行记录，Alice进行双花时，矿工检测到生成的key image已经存在就能发现双花攻击。<br><strong>注意</strong>：Monero中具体进行交易检验的细节内容，暂时没有深入的了解，待后续调研。</p>
<p>下图介绍了一个具体的Monero的交易信息，其中有多个输入，每个输入都会添加mix-ins，总共2个input和 3个output，每个input都有1个key image。第一个input使用了2个mix-in，第二个input使用了1个mix-ins。与Bitcoin一样，所有的input交易额之和应该等于所有的output交易额之和。<br><img src="https://img-blog.csdnimg.cn/20190408221604164.png" alt="在这里插入图片描述"></p>
<h3 id="RingCTs"><a href="#RingCTs" class="headerlink" title="RingCTs"></a>RingCTs</h3><p>2017年1月10日，Monero中上线了一种新的交易类型，称之为ring confidential transaction(RingCTs). 在一个RingCTs中，不仅隐藏了交易的真正input，同时也隐藏了交易额，在RingCTs中，每个output的交易额都标记为0,验证inputs和outputs的交易额相等的方法称之为commitment scheme，这里不再具体涉及。使用RingCTs的好处就是，转账进行mix-ins时，不用找相同价值的output，而是其他任意output都可以作为mix-ins。</p>
<h2 id="Monero-Network-Statics"><a href="#Monero-Network-Statics" class="headerlink" title="Monero Network Statics"></a>Monero Network Statics</h2><p>Monero区块链提供了Remote Procedure Calls(RPC)的方法，该论文通过RPC获取Monero区块链数据，RPC接口提供两个方法：getheight和getransactions，返回的JSON形式的文本。<br>    该论文分析的Monero区块链，截止时间为2017年1月10日，高度1240503，其中总共961463笔非coinbase交易，总共1339733个output，最大一笔输出为500000 XMR，其中85%的output的金额小于0.01 XMR。Monero区块链中output中XMR的分布图如下。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408221652783.png" alt="在这里插入图片描述"><br>在Monero中，规定output金额应该是A×10B的形式，其中1&lt;=A&lt;=9, B&gt;=-12。实际分析发现其中99.98%的output的金额并不符合Monero中output格式，同时其中92.8%的output金额在Monero中是唯一的，这些output总和是12231.27 XMR。Output金额不符合要求，是因为Monero中交易费用会根据交易大小而变化，交易的大小受mix-ins数量的影响，最终导致output值的不符合其规定。</p>
<h3 id="Number-of-MIx-ins"><a href="#Number-of-MIx-ins" class="headerlink" title="Number of MIx-ins"></a>Number of MIx-ins</h3><p>Min-ins的使用，各个input有所不同，最小的mix-ins是0，最大的mix-ins为851。但是其中[0,4]范围的mix-ins占比96%。不同mix-ins的使用的累积分布图如下：<br><img src="https://img-blog.csdnimg.cn/20190408221722424.png" alt="在这里插入图片描述"><br>这里面作者猜想大部分交易都是用数量较低的mix-ins的原因有两个，一方面有可能找不到足够多的等价值的output作为mix-ins，另外一方面，mix-ins的数量越多，意味着交易越大，交易越大则交易费越高。为了进一步对这两个原因进行分析，作者统计了mix-ins在0～11范围内所有对应交易中可以使用更高数量mix-ins的比例，其结果如Table 2所示，其中最后一列表示相应数量的mix-ins中，可以使用更高mix-ins的交易所占的比例，例如在mix-ins为2的交易总共2908304笔，但是其中2902246笔可以使用大于2的mix-ins，<strong>这说明Monero中大量交易使用较低的mix-ins不是因为没有足够的mix-ins，而是为了避免高额的手续费</strong>。<br><img src="https://img-blog.csdnimg.cn/20190408221747981.png" alt="在这里插入图片描述"></p>
<h3 id="Number-of-Inputs-and-Outputs"><a href="#Number-of-Inputs-and-Outputs" class="headerlink" title="Number of Inputs and Outputs"></a>Number of Inputs and Outputs</h3><p>在Monero区块链中input和output数量的变化情况如图4的统计所示。在Monero上线初期转账的时候，为了将output凑成A×10B的形式，因此会有很多输入和输出。Monero上线第一周，input和output的平均值分别为19和17，到第4周时input达到104，最后1周时下降到3，这是因为RingCTs技术的采用。<br><img src="https://img-blog.csdnimg.cn/2019040822182085.png" alt="在这里插入图片描述"><br>在采用RingCTs后，Monero中的output数量大幅下降，其平均值为2～4，然而input数量的变化却没有固定规律，主要是因为有很多input凑在一起支付的原因。在使用RingCTs后intput和output的情况如图5所示。<br><img src="https://img-blog.csdnimg.cn/20190408221839913.png" alt="在这里插入图片描述"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>对Monero区块链的统计分析情况，使用表3进行一个比较全面的总结。<br><img src="https://img-blog.csdnimg.cn/201904082219019.png" alt="在这里插入图片描述"></p>
<h2 id="Traceability-Attacking"><a href="#Traceability-Attacking" class="headerlink" title="Traceability Attacking"></a>Traceability Attacking</h2><h3 id="Heuristic-I"><a href="#Heuristic-I" class="headerlink" title="Heuristic I"></a>Heuristic I</h3><p>前文经过分析，作者发现了在Monero中，有65%的交易没有采用mix-ins技术，这就意味着这些交易中的所有input，都非常明确他们作为output是何时被花费出去的。因此，如果其他交易中使用了这些交易中的input作为mix-ins，那么就可以确定其他交易中真正被花销出去的output是哪一个，在文中作者称之为Cascade Effect，其效果如图6所示。<br><img src="https://img-blog.csdnimg.cn/20190408221932254.png" alt="在这里插入图片描述"><br>作者使用这种分析方法，逐渐减小一些交易中的匿名集合，直到匿名集合数量为1，于是就能确定真正被花销出去的output，最后根据这种方法追踪到了额外22%的交易。作者的追踪算法详细内容如下：<br><img src="https://img-blog.csdnimg.cn/20190408221948776.png" alt="在这里插入图片描述"><br>图7展示了交易追踪算法分别迭代1、3、5次之后追踪到的结果。在Figure 7a中，分别表示在mix-ins为0～10中，迭代1次、3次、5次能够追踪到的交易的比例。Figure 7b表示不同数量的mix-ins，迭代次数分别为1、3、5次时追踪到的交易的比例变化情况；Figure 7c表示随着时间（Week为单位）增长，不同迭代次数追踪到的交易比例，随着Monero中采用了RingCTs技术之后，Heuristic I已经无法追踪其中的inputs。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222003971.png" alt="在这里插入图片描述"><br>即使使用了Heuristic I，仍然有一些交易的input是无法追踪的，论文统计了mix-ins在-～1-范围内的情况，随着mix-ins数量增多，能准确追踪的input数量越来越少，针对mix-ins为10的input，其中24%的交易，其匿名集可以减少为2个input。统计情况如图8所示。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222021708.png" alt="在这里插入图片描述"></p>
<h3 id="Heuristic-II"><a href="#Heuristic-II" class="headerlink" title="Heuristic II"></a>Heuristic II</h3><p>Heuristic I的方法针对于没有使用RingCTs技术的Monero区块链分析有用，但是后续使用RingCTs的Monero区块链无能为力，于是作者使用了启发式方法II，该方法假设如果在交易Tx-a中，有2个input，其中一个input作为mix-ins，同时有2个输出O1和O2；如果在另外一笔交易Tx-b中，如果同时使用O1和O2作为input，那么则认为O1和O2隶属于同一个人；启发式方法2认为一笔交易中的inputs全部来自之前一笔交易的output的概率很低，如果出现这种情况，则认为这些input都会在这笔交易中被花出去。为了方便叙述，将Tx-a称之为source transaction，将Tx-b称之为 dest transaction，dest transaction的input中至少使用了source transaction中不少于2个的output。作者的假设可以参见图9。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222049979.png" alt="在这里插入图片描述"><br>由于启发式方法2是基于假设，因此基于假设的结果未必会有结论，同时还会又一些错误，论文作者也承认这一点，但是还是基于此不太靠谱的假设强行展开了分析并设计了算法，求解Monero使用RingCTs后的交易中是否存在一些dest transaction 使用了至少2个其他交易中的output，算法如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222105116.png" alt="在这里插入图片描述"><br>Algorithm 2 的运行情况有4种：</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222123639.png" alt="在这里插入图片描述"><br><strong>注意：我对这里面S2和S3的分类没有很明白有什么区别？找到several dest trx不是表明有给定的source，其output出现在多个dest 的input中吗？这和S3不就是一个意思吗？</strong></p>
<p>其中S1说明方法没有奏效，S2说明方法在transaction level中存在false positive；S3情况说明方法在input level 存在false positive；S4才是真正说明source 的outputs在dest中确实被花费了。<br>    为了评价方法的效果，分别统计4种情况出现的比例，同时以Heuristic I中获得的87%的数据作为真实数据，应用Heuristic II方法。首先经过统计总共找到410237种source trx，这些占比所有trx的43%， 其中包括636 笔包含RingCTs的trx，这只占RingCTs交易数的1%。将Heuristic II方法应用到不包含RingCTs的409601笔 trx中，其中60%的source trx 有1个对应的dest trx，其中1笔source trx能找到的dest trx的最大数目为146，对一个给定的dest trx，寻找对应的dest trx，dest trx数量增多，对应的source trx的比例逐步下降，如图Figure 10a所示。<br><img src="https://img-blog.csdnimg.cn/2019040822215451.png" alt="在这里插入图片描述"></p>
<p>Figure 10b中是将Heuristic II 的方法应用到 636笔RingCTs trx中，发现其中95.1%的source trx 仅仅对应1个dest trx。Figure 10c表示对应于non-RingCTs的交易，Heuristic II方法验证中，TP占有87.3%，而对于用户来说，Monero区块链采用RingCTs前后消费习惯没有多大变化，因此Heuristic II在RingCTs中的分析TP应该也占大部分的比例。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222222748.png" alt="在这里插入图片描述"></p>
<p>为了进一步说明在non-RingCTs中的结果比较可信，作者按照mix-ins的数量变化对Heuristic II方法的结果进行了统计，结果如图11所示，因为mix-ins数量增加，Heuristic I中可以追踪的交易数量大幅下降，因此针对Heuristic II中的结果，有一大部分是无法检测结果的正确性，但是即使如此，其中明确的False Positive几乎为0。</p>
<h3 id="Heuristic-III"><a href="#Heuristic-III" class="headerlink" title="Heuristic III"></a>Heuristic III</h3><p>启发式方法3的中，作者认为一个UTXO，随着时间的增长，其被花费的概率会越来越大，因此作者认为，在一个环形签名的公钥中，真正的转账地址应该是所在区块高度最高的那个地址（听起来有几分道理，如果有几个地址高度相同呢？），作者抱着试一试的想法，将这个启发式方法应用到non-RingCTs中的交易中，发现作者的方法，精确率能达到98.1%（看起来虽然是个扯淡的猜想，但是居然make sense！）为了规避这个问题，Monero developer在2015年4月5号将原本的mix-ins采样算法从正态分布换成了triangle distribution，这种采样中，对一个input，会挑选最近的output作为其mix-ins以解决这个问题。为了验证这种Monero developer采用的新的采样方式的效果，作者对2015年4月5号以后的交易进行了Heuristic III的分析，与之前的正态分布的采样下的结果比对，结果如表5所示，表5的情况说明采用新的采样方法之后，对于Heuristic III方法的影响不大。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222254166.png" alt="在这里插入图片描述"></p>
<p>为了对Heuristic III的方法的假设进行进一步的验证，对Heuristic I中确定的87%的交易进行了统计，分别统计这些UTXO在输出之后分别在什么时候被花销出去，作者对用户消费习惯进行如下分类，其中占比分别为：</p>
<ul>
<li>在[0,9]个区块内被花费的UTXO占比0.17%</li>
<li>在[10，100]范围内被花费的UTXO占比9.16%</li>
<li>在[101, 1000]范围内被花费的UTXo占比28.4%</li>
<li>[1000， +∞]范围内被花费的UTXO占比62.27%</li>
</ul>
<p>据此，分别计算得到一个概率密度图，如图12所示，作者建议依据此概率选择mix-ins更加合理。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408222348303.png" alt="在这里插入图片描述"></p>
<h2 id="Releated-Work-amp-amp-Conclusion"><a href="#Releated-Work-amp-amp-Conclusion" class="headerlink" title="Releated Work &amp;&amp; Conclusion"></a>Releated Work &amp;&amp; Conclusion</h2><p>本文的工作基于Menero Lab的两篇公开的文献MRL-001和MRL-002MRL-004。其中Heuristic I来自于MRL-001。本文的Heuristic II和Heuristic III分别来自于Monero-004。<br>本文最重要的贡献在于利用Heuristic I方法能够追踪到Monero 区块链中87%的交易，同时对于Monero Lab中对Monero做的一些改进进行了验证，Heuristic II和Heuristic III分别指出了改进方法的不足，同时给出建议，Monero Developer在进行mix-ins采样时可以考虑用户花费UTXO的习惯以提升匿名性。</p>
<h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><ul>
<li>相比于ZCash这篇论文，这篇文章中的作者为什么不在Monero中自己注册多个账号，然后多次进行转账，如果RingCTs中某个用户也恰恰使用1个mix-ins并且选中了作者的账号，那么就可以同样适用Heuristic I的方法，我就后续进行一些调研以验证我的想法，如果可以的话，就可以根据这篇文章的不足继续推进一些分析工作，例如可以分析Monero在采用了RingCTs技术之后匿名性/可追踪行到底如何？</li>
<li>本文的工作就量和质上与ZCash的那篇文章确有不及，这方面也令我看出发表一篇顶会，不仅需要原创、有效并且非常合理的想法，而且也需要有相当数量的分析工作，两者兼具，才能发到A类会议中。</li>
<li>对于RingCTs的使用方法、以及Monero中是如何防止双花的细节，我比较好奇，后续会进行一些调研。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/04/08/New Empirical Traceability Analysis of CryptoNote-Style Blockchains/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/08/New Empirical Traceability Analysis of CryptoNote-Style Blockchains/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">New Empirical Traceability Analysis of CryptoNote-Style Blockchains</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-04-08 17:00:14 / 更新于：22:40:19" itemprop="dateCreated datePublished" datetime="2019-04-08T17:00:14+08:00">2019-04-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>发表于Financial Cryptography and Data Security 2019的一篇文章。<br>文章链接：<a href="http://fc19.ifca.ai/preproceedings/69-preproceedings.pdf" target="_blank" rel="noopener">http://fc19.ifca.ai/preproceedings/69-preproceedings.pdf</a> </p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在（PETS’18）会议提出对Monero 不可追踪性的cascade effect 攻击已被开发者使用两个方法规避，其中之一是增加币环形签名(Ring Signature)中mix-ins的个数，从 0.9.0版本中的3个增加到了0.12.0版本中的7个，同时增加了ring confidential transactions(ringCTs)以提升隐私性。然而，目前并没有人对Monero当前应对的策略的匿名性进行分析。 改论文提出一种统计学分析，对所有CryptoNote类型的加密货币进行closed set attack.随后对Monero、Bytecoin以及DigitalNOte进行这种攻击，实验表明，结合了cascade attack之后的closed set attack能够识别出Monero中70.52%的input、Bytecoin中74.25%的inputs以及DigitalNote中91.56%的input。<br>随后对该种攻击成功的概率进行理论分析，发现成功概率为 2^19，closed set attack近似于statiscal attacks，据此，文中分析认为Monero当前的系统设置可以抵御statiscal attacks，另外文章分析说明了mix-ins不是越大越好，而是其中未被花费的input比例越高越好。</p>
<h2 id="Intruductioon"><a href="#Intruductioon" class="headerlink" title="Intruductioon"></a>Intruductioon</h2><p>   目前加密货币中用户的匿名性和隐私性都逐渐受到重视，因此出现了很多致力于保护用户隐私的加密货币，例如Monero、Bytecoin、Dash、DigitalNote、Boolberry等货币，这些货币都使用了CryptoNote 协议。在这些货币中，使用了ring signature(环形签名)技术，即在一笔交易的输入中，支付方会将自己的input地址和区块链中其他output地址混合起来形成一个环，这样做的目的是不让外界知道真正的input具体是哪一个，其他没有被花费的input称之为mix-ins。</p>
<p>   然而实际上Monero区块链中有65%的用户在花销的时候，使用的mix-ins为0，而这些交易很容易被确定真正的input，随后其他一些用户使用了这些被追踪的input作为mix-ins之后也面临着被追踪的危险，也确实有文章进行了相关分析，经过分析后发现其中87%的input都能被追踪到。随后Monero开发团队也对其进行了升级，其中引入了RingCTs技术，RingCTs技术中即使是不同数目的输入也可以作为mix-ins，同时将mix-ins的数量从2提升到了6（2019年3月29日的0.12.0版本）。但是实际上这些货币匿名性如何呢？</p>
<p>   本文中作者引入了closed set attack方式，简而言之就是如果有X个inputs的集合，其中恰好又有X个不同的地址，那么说明在这X个inputs中，不同的X个地址都已经被花销出去，因为每个inputs至少要消费一个地址。假若其他inputs中包含了这X中的地址，那么其他inputs的匿名集就可以减小，如果减小到1，就能够追踪到其中的交易。</p>
<h2 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h2><h3 id="CryptoNote-protocol"><a href="#CryptoNote-protocol" class="headerlink" title="CryptoNote protocol"></a>CryptoNote protocol</h3><p>   CryptoNote协议致力于做两件事情：</p>
<ul>
<li><strong>Untraceability：</strong> 对于任何交易，真正被花费的地址应该是在一系列outputs中匿名的作为inputs</li>
<li><p><strong>Unlinkability：</strong> 对于任意两个交易，不可能证明这两笔交易是发送给同一个用户的。</p>
<p>为了实现unlinkability，CryptoNote中每次转账时使用一个一次性地址，而这个一次性地址来源于接受者的公钥和发送者生成的一个随机数。 为了实现untraceability，CryptoNote中使用了环形签名。</p>
</li>
</ul>
<h2 id="Closed-Set-Attack"><a href="#Closed-Set-Attack" class="headerlink" title="Closed Set Attack"></a>Closed Set Attack</h2><p>   为了说明攻击方法，用txi.in表示每笔交易的输入，假设当前有4笔交易，每笔交易中的inputs分别是：</p>
<ul>
<li>tx1.in = &#123;pk1, pk2, pk3&#125;;</li>
<li>tx2.in = &#123;pk2, pk3&#125;;</li>
<li>tx3.in = &#123;pk1, pk3&#125;;</li>
<li>tx4.in = &#123;pk1, pk2, pk3, pk4&#125;.<br>其中pk表示public key， 即公钥。在tx1、tx2以及tx3中分别用到了pk1、pk2和pk3，而每个tx中都会花费一个pk，因此前3个交易必然是吧pk1、pk2和pk3已经花费掉了，在tx4中，很明显可以推出pk4是真正的花费地址。<br>应用理论分析应该是，在一系列交易中，所有的inputs的数量之和恰好等于这些inputs中不同地址的数目，那么其他应用这些不同地址作为mix-ins的交易，其匿名集中可以除去这些地址以减少其匿名集，如果匿名集和数量为1，那么这笔交易就成为可追踪交易了。</li>
</ul>
<h3 id="Definition-of-Cluster"><a href="#Definition-of-Cluster" class="headerlink" title="Definition of Cluster"></a>Definition of Cluster</h3><p>   那么这种攻击是如何进行的呢？文中定义一个Clus记为一个inputs的集合，Clus = &#123;R1， R2，…, Rn&#125;，每一个Clusetr中所有不同地址的集合，称之为PK_Clus，一个inputs我们使用R代表。假设已经存在一个Clus，那么一个inputs和Clus之间的差集定义为</p>
<ul>
<li>Dist(R, Clus)  = Dist(R, PK_Clus) = |R| - |PK_Clus∩R|<br>举例说明之，假设Clus = &#123;&#123;pk1, pk2&#125; ,  &#123;pk1, pk3&#125;, &#123;pk2, pk4&#125;&#125;, 那么PK_Clus = &#123;pk1,, pk2, pk3, pk4&#125;，假设某个R = &#123;pk1, pk3, pk5&#125;,  那么Dist(R, Clus) = 3-2 =1.</li>
</ul>
<h3 id="closed-set-Attack-Algorithm"><a href="#closed-set-Attack-Algorithm" class="headerlink" title="closed set Attack Algorithm"></a>closed set Attack Algorithm</h3><p>   为了进行closed set Attack，文中使用了一种聚类的方法，这种聚类的方法由两个算法构成，其中第二个算法调用了第1个算法。算法首先对所有的inputs应用Cascade-Effect攻击以减少其匿名集，随后对剩余的inputs集合输入到算法2中，Algorithm 2如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: Let DataSet be all transaction inputs in the blockchain.</span><br><span class="line"><span class="number">1.</span> Cascade-Effect(Dataset)</span><br><span class="line"><span class="number">2.</span> Flag = <span class="literal">true</span></span><br><span class="line"><span class="number">3.</span> <span class="keyword">while</span> Flag == <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="number">4.</span>     Flag = <span class="literal">false</span></span><br><span class="line"><span class="number">5.</span>     <span class="keyword">for</span> each R ∈ DataSet <span class="keyword">do</span></span><br><span class="line"><span class="number">6.</span>     Clus_Form(R) -&gt; Clus		<span class="comment">// 调用了Algorithm 1</span></span><br><span class="line"><span class="number">7.</span>     <span class="keyword">if</span> Clus is a closed <span class="built_in">set</span> then</span><br><span class="line"><span class="number">8.</span>        Remove(Clus) -&gt;Flag  <span class="comment">// 删除Dataset中的Clus集合</span></span><br><span class="line"><span class="number">9.</span>        <span class="keyword">if</span> Flag == <span class="literal">true</span> then</span><br><span class="line"><span class="number">10.</span>           find traceable inputs</span><br><span class="line"><span class="number">11.</span>           check whether rings inside Clus are traceable</span><br></pre></td></tr></table></figure>
<p>Algorithm 1算法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  Start with an input R, <span class="keyword">and</span> define the cluster as Clus = &amp;#<span class="number">123</span>;R&amp;#<span class="number">125</span>;</span><br><span class="line"><span class="number">2.</span> Let DataSet be all transaction inputs in the blockchain</span><br><span class="line"><span class="number">3.</span> <span class="function"><span class="keyword">for</span> each <span class="title">R1</span><span class="params">(≠ R)</span> 2 DataSet <span class="keyword">do</span></span></span><br><span class="line">4.     if Dist(R1， Clus) ≤ 1 then</span><br><span class="line"><span class="number">5.</span>         Clus = Clus ∪ &amp;#<span class="number">123</span>;R1&amp;#<span class="number">125</span>;</span><br><span class="line"><span class="number">6.</span> <span class="keyword">return</span> Clus</span><br></pre></td></tr></table></figure></p>
<p>对于Dataset中的所有inputs，迭代使用Algorithm 2，假设所有inputs个数为N，而每个R的长度为L，那么总的算法复杂度为θ(LN²) 。</p>
<h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><h3 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h3><p>   本文收集了从Monero区块链创世块(2014年4月18日)到2018年3月30日的区块，总共1541236个区块，工2612070笔非coinbase 交易。</p>
<h3 id="Experiment-Result"><a href="#Experiment-Result" class="headerlink" title="Experiment Result"></a>Experiment Result</h3><p>将本文方法应用于Monero区块链分析，首先应用Cascade effect attack，发现其中16334967笔交易可追踪，而closed set总工追踪到了5752笔交易，因此总共追踪到70.52%的inputs。追踪结果如下表所示。总共找到3017个closed set，大小从2到55不等，总共包含了7478个public_keys，这些public keys已经被花销了，如果其他输入使用这些inputs作为mix-ins，那么是无效的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mix-insg个数</th>
<th>inputs数</th>
<th>共可追踪inputs数</th>
<th>Cascade Effect</th>
<th>Closed set</th>
<th>百分比</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>12209675</td>
<td>12209675</td>
<td>12209675</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>707786</td>
<td>625641</td>
<td>625264</td>
<td>377</td>
<td>88.39</td>
</tr>
<tr>
<td>2</td>
<td>4496490</td>
<td>1779134</td>
<td>1776192</td>
<td>2942</td>
<td>39.57</td>
</tr>
<tr>
<td>3</td>
<td>1486593</td>
<td>952855</td>
<td>951984</td>
<td>871</td>
<td>64.10</td>
</tr>
<tr>
<td>4</td>
<td>3242625</td>
<td>451959</td>
<td>451230</td>
<td>729</td>
<td>13.94</td>
</tr>
<tr>
<td>5</td>
<td>319352</td>
<td>74186</td>
<td>73980</td>
<td>206</td>
<td>23.23</td>
</tr>
<tr>
<td>6</td>
<td>432875</td>
<td>202360</td>
<td>202100</td>
<td>260</td>
<td>46.75</td>
</tr>
<tr>
<td>7</td>
<td>21528</td>
<td>4296</td>
<td>4282</td>
<td>14</td>
<td>19.96</td>
</tr>
<tr>
<td>8</td>
<td>30067</td>
<td>3506</td>
<td>3490</td>
<td>16</td>
<td>11.66</td>
</tr>
<tr>
<td>9</td>
<td>17724</td>
<td>2178</td>
<td>2162</td>
<td>16</td>
<td>12.29</td>
</tr>
<tr>
<td>Total</td>
<td>≥10</td>
<td>200030</td>
<td>29177</td>
<td>28856</td>
<td>321</td>
<td>14.59</td>
</tr>
</tbody>
</table>
</div>
<p>最后还剩余6829778笔inputs仍然不可追踪，但是这些交易的匿名集已经大大减少，减少情况如下图所示。可以看到，很多之前inputs中地址很多，但是经过closed set分析之后币有多都可以识别，其中inputs你们集合是1的，当下有超过100万，想办法进一步进行分析，或许可以有更多收获。不过作者并没有进一步分析。</p>
<p><img src="https://img-blog.csdnimg.cn/20190408163804418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>此外，作者分别对Bytecoin和DigitalNote进行了同样的分析，分析的结果没有过多需要介绍的，因此这里略过。</p>
<h2 id="Observations-and-Recommendations"><a href="#Observations-and-Recommendations" class="headerlink" title="Observations and Recommendations"></a>Observations and Recommendations</h2><ul>
<li><strong>Obervation 1：</strong> 区块链中outputs的使用率是匿名性中一个非常重要的因素，因为每个outputs毕竟只能被redeem 1次，因此低的使用量能提升匿名性。</li>
<li><strong>Obervation 2：</strong> Closed sets与intpus的匿名性息息相关，找到Closed sets有助于减少匿名集和找到real spent，虽然其数量不多，但是仍然会威胁到匿名集。</li>
<li><strong>Recommendation 1：</strong> 为了减少outputs的使用率，应该增加更多的outputs，建议用户增加一些价值为0 的输出。(PS:输出越多，花费的交易费越多，用户愿意吗？)</li>
<li><strong>Recommendation 2：</strong> 不用使用无效的mix-ins。PS：如果用户知道的话，用户当然不会使用了。</li>
</ul>
<h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>这篇文章就提出了1种攻击方式，相比于其他文章来说，在内容和分析展示情况上都显示出比较单一，个人觉得提出的方法很好，但是并没有很好地挖掘这种方法之后的结果，这种方法已经将匿名集降低到1了，此时如果在坚持一下，或者在想想别的分析方法，那么就不是简单的发表在FC上了，可以冲击一下B类会议。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/03/28/EOS中plugin之net-plugin/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/EOS中plugin之net-plugin/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">EOS中plugin之net_plugin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-28 14:15:24" itemprop="dateCreated datePublished" datetime="2019-03-28T14:15:24+08:00">2019-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-04-08 22:31:11" itemprop="dateModified" datetime="2019-04-08T22:31:11+08:00">2019-04-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这部分重点介绍EOS中的服务器端部分nodeos启动之后开启的另外一个重要的插件——net_plugin，这个插件主要负责服务器在网络中的接入、同步区块信息、断开等功能。对于这个插件，首先从其类的定义开始了解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">net_plugin</span> :</span> <span class="keyword">public</span> appbase::plugin&lt;net_plugin&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    net_plugin();</span><br><span class="line">    <span class="keyword">virtual</span> ~net_plugin();</span><br><span class="line"></span><br><span class="line">    APPBASE_PLUGIN_REQUIRES((chain_plugin))    <span class="comment">// net_plugin这个插件的启动，依赖chain_plugin插件</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_program_options</span><span class="params">(options_description&amp; cli, options_description&amp; cfg)</span> override</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plugin_initialize</span><span class="params">(<span class="keyword">const</span> variables_map&amp; options)</span></span>;  <span class="comment">// 插件初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plugin_startup</span><span class="params">()</span></span>;                                 <span class="comment">// 插件的启动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">plugin_shutdown</span><span class="params">()</span></span>;                                <span class="comment">// 插件关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>   <span class="title">broadcast_block</span><span class="params">(<span class="keyword">const</span> chain::signed_block &amp;sb)</span></span>; <span class="comment">// 广播区块</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span>                       <span class="title">connect</span><span class="params">( <span class="keyword">const</span> <span class="built_in">string</span>&amp; endpoint )</span></span>; <span class="comment">// 连接其他端点</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span>                       <span class="title">disconnect</span><span class="params">( <span class="keyword">const</span> <span class="built_in">string</span>&amp; endpoint )</span></span>; <span class="comment">// 断开连接</span></span><br><span class="line">    optional&lt;connection_status&gt;  status( <span class="keyword">const</span> <span class="built_in">string</span>&amp; endpoint )<span class="keyword">const</span>;   <span class="comment">// 查看与某个端点的链接状态</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;connection_status&gt;    connections()<span class="keyword">const</span>;                   <span class="comment">// 查看连接状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> num_peers() <span class="keyword">const</span>;                                          <span class="comment">// 查看建立连接的端点个数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">net_plugin_impl</span>&gt; <span class="title">my</span>;</span>   <span class="comment">// 和producer_plugin_imple一样，这个插件负责网络中的具体操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>net_plugin插件的代码还是比较容易理解的，net_plugin的初始化函数非常简单，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net_plugin::net_plugin()</span><br><span class="line">    :my( <span class="keyword">new</span> net_plugin_impl ) &#123;</span><br><span class="line">    my_impl = my.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化函数中生成了一阁net_plugin_impl的实例，随后将my的指针赋值给了net_plugin_impl类中的定义的静态指针,这个静态指针的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> net_plugin_impl *my_impl;</span><br></pre></td></tr></table></figure>
<p>再nodeos的main函数中，net_plugin首先会初始化，随后调用其plugin_initialize函数和<a href="https://hzxgoforward.github.io/2019/03/20/EOS%E4%B8%ADplugin%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/">EOS中lugin之producer_plugin</a>的介绍的procuder_plugin类初始化方式时一样的，先寻找这个插件依赖的插件，然后初始化依赖的插件、一些启动参数，设置心跳计时器等。</p>
<p>nodeos中初始化完毕，随后调用net_plugin的plugin_startup函数，该函数代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> net_plugin::plugin_startup() &#123;</span><br><span class="line">    my-&gt;producer_plug = app().find_plugin&lt;producer_plugin&gt;();</span><br><span class="line">    <span class="keyword">if</span>( my-&gt;acceptor ) &#123;</span><br><span class="line">        <span class="comment">// 常见的网络服务操作,打开监听服务,设置选项,绑定地址,启动监听</span></span><br><span class="line">        my-&gt;acceptor-&gt;open(my-&gt;listen_endpoint.protocol());</span><br><span class="line">        my-&gt;acceptor-&gt;set_option(tcp::acceptor::reuse_address(<span class="literal">true</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// acceptor 来自于boost::asio::ip::tcp，即tcp::acceptor</span></span><br><span class="line">        my-&gt;acceptor-&gt;bind(my-&gt;listen_endpoint);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        ilog(<span class="string">"net_plugin::plugin_startup failed to bind to port $&#123;port&#125;"</span>,</span><br><span class="line">            (<span class="string">"port"</span>, my-&gt;listen_endpoint.port()));</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        my-&gt;acceptor-&gt;listen();</span><br><span class="line">        ilog(<span class="string">"starting listener, max clients is $&#123;mc&#125;"</span>,(<span class="string">"mc"</span>,my-&gt;max_client_count));</span><br><span class="line">        my-&gt;start_listen_loop();   <span class="comment">// 循环监听函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    chain::controller&amp;cc = my-&gt;chain_plug-&gt;chain();</span><br><span class="line">    &#123;</span><br><span class="line">        cc.accepted_block.connect(  boost::bind(&amp;net_plugin_impl::accepted_block, my.get(), _1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    my-&gt;incoming_transaction_ack_subscription = app().get_channel&lt;channels::transaction_ack&gt;().subscribe(boost::bind(&amp;net_plugin_impl::transaction_ack, my.get(), _1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( cc.get_read_mode() == chain::db_read_mode::READ_ONLY ) &#123;</span><br><span class="line">        my-&gt;max_nodes_per_host = <span class="number">0</span>;</span><br><span class="line">        ilog( <span class="string">"node in read-only mode setting max_nodes_per_host to 0 to prevent connections"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动连接和交易到期的监视</span></span><br><span class="line">    my-&gt;start_monitors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> seed_node : my-&gt;supplied_peers ) &#123;</span><br><span class="line">        connect( seed_node );<span class="comment">// 连接种子节点,接入p2p网络</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fc::get_logger_map().find(logger_name) != fc::get_logger_map().end())</span><br><span class="line">        logger = fc::get_logger_map()[logger_name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先打开监听的端口号，设置相关协议，随后绑定端口号，然后开始监听网络中的信息，同时让本端点连接到网络中的种子节点，以此连接EOS中的p2p网络。这里面最重要的2个函数是 my-&gt;start_listen_loop()以及my-&gt;start_monitors()函数,my-&gt;start_listen_loop，通过函数名称可以断定主要用来不断地从网络中监听网络中发送的信息，my-&gt;start_monitors()应该是进行监听，但是到底监听什么，我们还不得而知。</p>
<p>这里暂时先不对net_plugin_impl进行具体解析，因为这并不影响我们对这两个函数的分析，另外一方面，net_plugin_impl的介绍对于这两个函数的分析，帮助不大。<br>因此，我们直接进入start_listen_loop函数一探究竟。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 该函数循环监听信息</span></span><br><span class="line"><span class="keyword">void</span> net_plugin_impl::start_listen_loop() &#123;</span><br><span class="line">    <span class="keyword">auto</span> socket = <span class="built_in">std</span>::make_shared&lt;tcp::socket&gt;( <span class="built_in">std</span>::ref( app().get_io_service() ) );</span><br><span class="line">    acceptor-&gt;async_accept( *socket, [socket,<span class="keyword">this</span>]( boost::system::error_code ec ) &#123;</span><br><span class="line">        <span class="keyword">if</span>( !ec ) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> visitors = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> from_addr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> paddr = socket-&gt;remote_endpoint(ec).address();</span><br><span class="line">            <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">                fc_elog(logger,<span class="string">"Error getting remote endpoint: $&#123;m&#125;"</span>,(<span class="string">"m"</span>, ec.message()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;conn : connections) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(conn-&gt;socket-&gt;is_open()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (conn-&gt;peer_addr.empty()) &#123;</span><br><span class="line">                        visitors++;</span><br><span class="line">                        boost::system::error_code ec;</span><br><span class="line">                        <span class="keyword">if</span> (paddr == conn-&gt;socket-&gt;remote_endpoint(ec).address()) &#123;</span><br><span class="line">                            from_addr++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num_clients != visitors) &#123;</span><br><span class="line">                    ilog(<span class="string">"checking max client, visitors = $&#123;v&#125; num clients $&#123;n&#125;"</span>,(<span class="string">"v"</span>,visitors)(<span class="string">"n"</span>,num_clients));</span><br><span class="line">                    num_clients = visitors;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( from_addr &lt; max_nodes_per_host &amp;&amp; (max_client_count == <span class="number">0</span> || num_clients &lt; max_client_count )) &#123;</span><br><span class="line">                    ++num_clients;</span><br><span class="line">                    connection_ptr c = <span class="built_in">std</span>::make_shared&lt;connection&gt;( socket );</span><br><span class="line">                    connections.insert( c );</span><br><span class="line">                    start_session( c );</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (from_addr &gt;= max_nodes_per_host) &#123;</span><br><span class="line">                    fc_elog(logger, <span class="string">"Number of connections ($&#123;n&#125;) from $&#123;ra&#125; exceeds limit"</span>,</span><br><span class="line">                            (<span class="string">"n"</span>, from_addr+<span class="number">1</span>)(<span class="string">"ra"</span>,paddr.to_string()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                    fc_elog(logger, <span class="string">"Error max_client_count $&#123;m&#125; exceeded"</span>,</span><br><span class="line">                            ( <span class="string">"m"</span>, max_client_count) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    socket-&gt;close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            elog( <span class="string">"Error accepting connection: $&#123;m&#125;"</span>,( <span class="string">"m"</span>, ec.message() ) );</span><br><span class="line">            <span class="comment">// For the listed error codes below, recall start_listen_loop()</span></span><br><span class="line">            <span class="keyword">switch</span> (ec.value()) &#123;</span><br><span class="line">                <span class="keyword">case</span> ECONNABORTED:</span><br><span class="line">                <span class="keyword">case</span> EMFILE:</span><br><span class="line">                <span class="keyword">case</span> ENFILE:</span><br><span class="line">                <span class="keyword">case</span> ENOBUFS:</span><br><span class="line">                <span class="keyword">case</span> ENOMEM:</span><br><span class="line">                <span class="keyword">case</span> EPROTO:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        start_listen_loop();</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start_listen_loop()函数中最重要的一个函数是，监听到消息之后的start_session()函数，表示监听到了新的链接，于是开始会话。start_session()函数内容如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> net_plugin_impl::start_session(<span class="keyword">const</span> connection_ptr&amp; con) &#123;</span><br><span class="line">    boost::asio::ip::tcp::<span class="function">no_delay <span class="title">nodelay</span><span class="params">( <span class="literal">true</span> )</span></span>;</span><br><span class="line">    boost::system::error_code ec;</span><br><span class="line">    con-&gt;socket-&gt;set_option( nodelay, ec );</span><br><span class="line">    <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">        <span class="comment">// 如果接受数据出错， 直接关闭连接，写日志</span></span><br><span class="line">        elog( <span class="string">"connection failed to $&#123;peer&#125;: $&#123;error&#125;"</span>,</span><br><span class="line">            ( <span class="string">"peer"</span>, con-&gt;peer_name())(<span class="string">"error"</span>,ec.message()));</span><br><span class="line">        con-&gt;connecting = <span class="literal">false</span>;</span><br><span class="line">        close(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据，已经开启的session+1</span></span><br><span class="line">        start_read_message( con );</span><br><span class="line">        ++started_sessions;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// for now, we can just use the application main loop.</span></span><br><span class="line">        <span class="comment">//     con-&gt;readloop_complete  = bf::async( [=]()&#123; read_loop( con ); &#125; );</span></span><br><span class="line">        <span class="comment">//     con-&gt;writeloop_complete = bf::async( [=]()&#123; write_loop con ); &#125; );</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重要的是start_read_message，即回话过程中读取数据，即start_read_message()函数，其具体内容如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> net_plugin_impl::start_read_message(<span class="keyword">const</span> connection_ptr&amp; conn) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!conn-&gt;socket) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        connection_wptr weak_conn = conn;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> minimum_read = conn-&gt;outstanding_read_bytes ? *conn-&gt;outstanding_read_bytes : message_header_size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认为false，在plugin_initialized中使用</span></span><br><span class="line">        <span class="keyword">if</span> (use_socket_read_watermark) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> max_socket_read_watermark = <span class="number">4096</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> socket_read_watermark = <span class="built_in">std</span>::min&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(minimum_read, max_socket_read_watermark);</span><br><span class="line">        boost::asio::socket_base::<span class="function">receive_low_watermark <span class="title">read_watermark_opt</span><span class="params">(socket_read_watermark)</span></span>;</span><br><span class="line">        conn-&gt;socket-&gt;set_option(read_watermark_opt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> completion_handler = [minimum_read](boost::system::error_code ec, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred) -&gt; <span class="built_in">std</span>::<span class="keyword">size_t</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ec || bytes_transferred &gt;= minimum_read ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minimum_read - bytes_transferred;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从stream中异步读取固定大小的数据</span></span><br><span class="line">        <span class="comment">/* async_read(AsyncReadStream &amp;S, const MutableBufferSequence&amp; buffers, ReadHandler&amp;&amp; handler, )</span></span><br><span class="line"><span class="comment">        从*conn-&gt;socket中读取data，读到buffers中去，buffers的大小告诉系统读取多少</span></span><br><span class="line"><span class="comment">        handler是读取数据完毕之后调用的函数 */</span></span><br><span class="line">        boost::asio::async_read(*conn-&gt;socket,</span><br><span class="line">        conn-&gt;pending_message_buffer.get_buffer_sequence_for_boost_async_read(), </span><br><span class="line">        completion_handler,</span><br><span class="line">        [<span class="keyword">this</span>,weak_conn]( boost::system::error_code ec, <span class="built_in">std</span>::<span class="keyword">size_t</span> bytes_transferred ) &#123;</span><br><span class="line">            <span class="keyword">auto</span> conn = weak_conn.lock();</span><br><span class="line">            <span class="keyword">if</span> (!conn) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            conn-&gt;outstanding_read_bytes.reset();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>( !ec ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bytes_transferred &gt; conn-&gt;pending_message_buffer.bytes_to_write()) &#123;</span><br><span class="line">                    elog(<span class="string">"async_read_some callback: bytes_transfered = $&#123;bt&#125;, buffer.bytes_to_write = $&#123;btw&#125;"</span>,</span><br><span class="line">                            (<span class="string">"bt"</span>,bytes_transferred)(<span class="string">"btw"</span>,conn-&gt;pending_message_buffer.bytes_to_write()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    EOS_ASSERT(bytes_transferred &lt;= conn-&gt;pending_message_buffer.bytes_to_write(), plugin_exception, <span class="string">""</span>);</span><br><span class="line">                    conn-&gt;pending_message_buffer.advance_write_ptr(bytes_transferred);</span><br><span class="line">                    <span class="keyword">while</span> (conn-&gt;pending_message_buffer.bytes_to_read() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">uint32_t</span> bytes_in_buffer = conn-&gt;pending_message_buffer.bytes_to_read();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (bytes_in_buffer &lt; message_header_size) &#123;</span><br><span class="line">                        conn-&gt;outstanding_read_bytes.emplace(message_header_size - bytes_in_buffer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">uint32_t</span> message_length;</span><br><span class="line">                        <span class="keyword">auto</span> index = conn-&gt;pending_message_buffer.read_index();</span><br><span class="line">                        conn-&gt;pending_message_buffer.peek(&amp;message_length, <span class="keyword">sizeof</span>(message_length), index);</span><br><span class="line">                        <span class="keyword">if</span>(message_length &gt; def_send_buffer_size*<span class="number">2</span> || message_length == <span class="number">0</span>) &#123;</span><br><span class="line">                            boost::system::error_code ec;</span><br><span class="line">                            elog(<span class="string">"incoming message length unexpected ($&#123;i&#125;), from $&#123;p&#125;"</span>,</span><br><span class="line">                                (<span class="string">"i"</span>, message_length)(<span class="string">"p"</span>,boost::lexical_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(conn-&gt;socket-&gt;remote_endpoint(ec))));</span><br><span class="line">                            close(conn);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span> total_message_bytes = message_length + message_header_size;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (bytes_in_buffer &gt;= total_message_bytes) &#123;</span><br><span class="line">                            conn-&gt;pending_message_buffer.advance_read_ptr(message_header_size);</span><br><span class="line">                            <span class="comment">// 这一部分是网络通信的内容，对于其中细节不甚了解</span></span><br><span class="line">                            <span class="comment">// 接收的数据传递到pending_message_buffer中，</span></span><br><span class="line">                            <span class="comment">// process_next_message中进行处理从pending_message_buffer中处理数据</span></span><br><span class="line">                            <span class="keyword">if</span> (!conn-&gt;process_next_message(*<span class="keyword">this</span>, message_length)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">auto</span> outstanding_message_bytes = total_message_bytes - bytes_in_buffer;</span><br><span class="line">                            <span class="keyword">auto</span> available_buffer_bytes = conn-&gt;pending_message_buffer.bytes_to_write();</span><br><span class="line">                            <span class="keyword">if</span> (outstanding_message_bytes &gt; available_buffer_bytes) &#123;</span><br><span class="line">                                conn-&gt;pending_message_buffer.add_space( outstanding_message_bytes - available_buffer_bytes );</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            conn-&gt;outstanding_read_bytes.emplace(outstanding_message_bytes);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    start_read_message(conn);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">auto</span> pname = conn-&gt;peer_name();</span><br><span class="line">                    <span class="keyword">if</span> (ec.value() != boost::asio::error::eof) &#123;</span><br><span class="line">                    elog( <span class="string">"Error reading message from $&#123;p&#125;: $&#123;m&#125;"</span>,(<span class="string">"p"</span>,pname)( <span class="string">"m"</span>, ec.message() ) );</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ilog( <span class="string">"Peer $&#123;p&#125; closed connection"</span>,(<span class="string">"p"</span>,pname) );</span><br><span class="line">                    &#125;</span><br><span class="line">                    close( conn );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex) &#123;</span><br><span class="line">                <span class="built_in">string</span> pname = conn ? conn-&gt;peer_name() : <span class="string">"no connection name"</span>;</span><br><span class="line">                elog(<span class="string">"Exception in handling read data from $&#123;p&#125; $&#123;s&#125;"</span>,(<span class="string">"p"</span>,pname)(<span class="string">"s"</span>,ex.what()));</span><br><span class="line">                close( conn );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(<span class="keyword">const</span> fc::exception &amp;ex) &#123;</span><br><span class="line">                <span class="built_in">string</span> pname = conn ? conn-&gt;peer_name() : <span class="string">"no connection name"</span>;</span><br><span class="line">                elog(<span class="string">"Exception in handling read data $&#123;s&#125;"</span>, (<span class="string">"p"</span>,pname)(<span class="string">"s"</span>,ex.to_string()));</span><br><span class="line">                close( conn );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">                <span class="built_in">string</span> pname = conn ? conn-&gt;peer_name() : <span class="string">"no connection name"</span>;</span><br><span class="line">                elog( <span class="string">"Undefined exception hanlding the read data from connection $&#123;p&#125;"</span>,( <span class="string">"p"</span>,pname));</span><br><span class="line">                close( conn );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">string</span> pname = conn ? conn-&gt;peer_name() : <span class="string">"no connection name"</span>;</span><br><span class="line">        elog( <span class="string">"Undefined exception handling reading $&#123;p&#125;"</span>,(<span class="string">"p"</span>,pname) );</span><br><span class="line">        close( conn );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛去其中try catch语句，我们重点看到conn-&gt;process_next_message函数，这个函数正如注释所说，从接受到的pending_message_buffer中处理数据，我们继续追踪这个处理函数，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该函数用于数据同步,使用中心消息处理系统处理数据</span></span><br><span class="line"><span class="keyword">bool</span> connection::process_next_message(net_plugin_impl&amp; impl, <span class="keyword">uint32_t</span> message_length) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> ds = pending_message_buffer.create_datastream();</span><br><span class="line">        net_message msg;</span><br><span class="line">        fc::raw::unpack(ds, msg);  <span class="comment">// 将解压的ds信息放入msg中</span></span><br><span class="line">        <span class="function">msg_handler <span class="title">m</span><span class="params">(impl, shared_from_this() )</span></span>;</span><br><span class="line">        <span class="comment">// 判断msg的类型，msg可以是带签名的区块或者打包后的交易</span></span><br><span class="line">        <span class="comment">// 如果是区块，获取signed_block后放入m中</span></span><br><span class="line">        <span class="comment">// 如果是trx，则获取packed_trx后放入m中</span></span><br><span class="line">        <span class="keyword">if</span>( msg.contains&lt;signed_block&gt;() ) &#123;</span><br><span class="line">        m( <span class="built_in">std</span>::move( msg.get&lt;signed_block&gt;() ) );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( msg.contains&lt;packed_transaction&gt;() ) &#123;</span><br><span class="line">        m( <span class="built_in">std</span>::move( msg.get&lt;packed_transaction&gt;() ) );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg.visit( m );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(  <span class="keyword">const</span> fc::exception&amp; e ) &#123;</span><br><span class="line">        edump((e.to_detail_string() ));</span><br><span class="line">        impl.close( shared_from_this() );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中重要的是msg_handler类型，这里面分别针对消息不同的类型做不同的处理，首先查看针对如果msg中包含了signed_block，则进入处理block函数；如果msg中包含packed_transaction，则进入处理trx的函数。首先查看msg_handler是如何处理signed_block的，处理区块的函数如下。收到区块之后验证区块，验证通过则接受区块，验证失败则拒绝区块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果从网络中收到一个区块，执行相应的处理</span></span><br><span class="line"><span class="keyword">void</span> net_plugin_impl::handle_message(<span class="keyword">const</span> connection_ptr&amp; c, <span class="keyword">const</span> signed_block_ptr&amp; msg) &#123;</span><br><span class="line">   controller &amp;cc = chain_plug-&gt;chain();</span><br><span class="line">   block_id_type blk_id = msg-&gt;id();</span><br><span class="line">   <span class="keyword">uint32_t</span> blk_num = msg-&gt;block_num();</span><br><span class="line">   fc_dlog(logger, <span class="string">"canceling wait on $&#123;p&#125;"</span>, (<span class="string">"p"</span>,c-&gt;peer_name()));</span><br><span class="line">   c-&gt;cancel_wait();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>( cc.fetch_block_by_id(blk_id)) &#123;</span><br><span class="line">         <span class="comment">// recv_block函数具体含义为止，同步区块数据？不应该是检查在先？</span></span><br><span class="line">         sync_master-&gt;recv_block(c, blk_id, blk_num);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span>( ...) &#123;</span><br><span class="line">      <span class="comment">// should this even be caught?</span></span><br><span class="line">      elog(<span class="string">"Caught an unknown exception trying to recall blockID"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   dispatcher-&gt;recv_block(c, blk_id, blk_num);  <span class="comment">// 进行报告，我已经从连接c收到一个编号blk_id和blk_num的区块？</span></span><br><span class="line">   fc::<span class="function">microseconds <span class="title">age</span><span class="params">( fc::time_point::now() - msg-&gt;timestamp)</span></span>;</span><br><span class="line">   peer_ilog(c, <span class="string">"received signed_block : #$&#123;n&#125; block age in secs = $&#123;age&#125;"</span>,</span><br><span class="line">           (<span class="string">"n"</span>,blk_num)(<span class="string">"age"</span>,age.to_seconds()));</span><br><span class="line"></span><br><span class="line">   go_away_reason reason = fatal_other;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 在chain_plug中再检查其具体含义，看catch中的内容，应该是使用chain_plug对区块进行检查</span></span><br><span class="line">      <span class="comment">// 如果检查无错误，reason的值应该是no_reason</span></span><br><span class="line">      chain_plug-&gt;accept_block(msg); <span class="comment">//, sync_master-&gt;is_active(c));</span></span><br><span class="line">      reason = no_reason;</span><br><span class="line">   &#125; <span class="keyword">catch</span>( <span class="keyword">const</span> unlinkable_block_exception &amp;ex) &#123;</span><br><span class="line">      peer_elog(c, <span class="string">"bad signed_block : $&#123;m&#125;"</span>, (<span class="string">"m"</span>,ex.what()));</span><br><span class="line">      reason = unlinkable;</span><br><span class="line">   &#125; <span class="keyword">catch</span>( <span class="keyword">const</span> block_validate_exception &amp;ex) &#123;</span><br><span class="line">      peer_elog(c, <span class="string">"bad signed_block : $&#123;m&#125;"</span>, (<span class="string">"m"</span>,ex.what()));</span><br><span class="line">      elog( <span class="string">"block_validate_exception accept block #$&#123;n&#125; syncing from $&#123;p&#125;"</span>,(<span class="string">"n"</span>,blk_num)(<span class="string">"p"</span>,c-&gt;peer_name()));</span><br><span class="line">      reason = validation;</span><br><span class="line">   &#125; <span class="keyword">catch</span>( <span class="keyword">const</span> assert_exception &amp;ex) &#123;</span><br><span class="line">      peer_elog(c, <span class="string">"bad signed_block : $&#123;m&#125;"</span>, (<span class="string">"m"</span>,ex.what()));</span><br><span class="line">      elog( <span class="string">"unable to accept block on assert exception $&#123;n&#125; from $&#123;p&#125;"</span>,(<span class="string">"n"</span>,ex.to_string())(<span class="string">"p"</span>,c-&gt;peer_name()));</span><br><span class="line">   &#125; <span class="keyword">catch</span>( <span class="keyword">const</span> fc::exception &amp;ex) &#123;</span><br><span class="line">      peer_elog(c, <span class="string">"bad signed_block : $&#123;m&#125;"</span>, (<span class="string">"m"</span>,ex.what()));</span><br><span class="line">      elog( <span class="string">"accept_block threw a non-assert exception $&#123;x&#125; from $&#123;p&#125;"</span>,( <span class="string">"x"</span>,ex.to_string())(<span class="string">"p"</span>,c-&gt;peer_name()));</span><br><span class="line">      reason = no_reason;</span><br><span class="line">   &#125; <span class="keyword">catch</span>( ...) &#123;</span><br><span class="line">      peer_elog(c, <span class="string">"bad signed_block : unknown exception"</span>);</span><br><span class="line">      elog( <span class="string">"handle sync block caught something else from $&#123;p&#125;"</span>,(<span class="string">"num"</span>,blk_num)(<span class="string">"p"</span>,c-&gt;peer_name()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">update_block_num <span class="title">ubn</span><span class="params">(blk_num)</span></span>;</span><br><span class="line">   <span class="keyword">if</span>( reason == no_reason ) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;recpt : msg-&gt;transactions) &#123;</span><br><span class="line">         <span class="keyword">auto</span> id = (recpt.trx.which() == <span class="number">0</span>) ? recpt.trx.get&lt;transaction_id_type&gt;() : recpt.trx.get&lt;packed_transaction&gt;().id();</span><br><span class="line">         <span class="keyword">auto</span> ltx = local_txns.get&lt;by_id&gt;().find(id);</span><br><span class="line">         <span class="keyword">if</span>( ltx != local_txns.end()) &#123;</span><br><span class="line">            local_txns.modify( ltx, ubn );</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">auto</span> ctx = c-&gt;trx_state.get&lt;by_id&gt;().find(id);</span><br><span class="line">         <span class="keyword">if</span>( ctx != c-&gt;trx_state.end()) &#123;</span><br><span class="line">            c-&gt;trx_state.modify( ctx, ubn );</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这里再次进行recv_block，不明白其含义</span></span><br><span class="line">      sync_master-&gt;recv_block(c, blk_id, blk_num);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 验证区块过程中出现错误，直接拒绝这个区块</span></span><br><span class="line">      sync_master-&gt;rejected_block(c, blk_num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对交易的验证与对区块的处理方式相同，验证交易，如果本地存在此交易，则丢弃，否则开始验证交易，若验证通过则接受交易并广播交易，否则拒绝交易。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> net_plugin_impl::handle_message(<span class="keyword">const</span> connection_ptr&amp; c, <span class="keyword">const</span> packed_transaction_ptr&amp; trx) &#123;</span><br><span class="line">    fc_dlog(logger, <span class="string">"got a packed transaction, cancel wait"</span>);</span><br><span class="line">    peer_ilog(c, <span class="string">"received packed_transaction"</span>);</span><br><span class="line">    controller&amp; cc = my_impl-&gt;chain_plug-&gt;chain();</span><br><span class="line">    <span class="keyword">if</span>( cc.get_read_mode() == eosio::db_read_mode::READ_ONLY ) &#123;</span><br><span class="line">        fc_dlog(logger, <span class="string">"got a txn in read-only mode - dropping"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( sync_master-&gt;is_active(c) ) &#123;</span><br><span class="line">        fc_dlog(logger, <span class="string">"got a txn during sync - dropping"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ptrx = <span class="built_in">std</span>::make_shared&lt;transaction_metadata&gt;( trx );</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tid = ptrx-&gt;id;</span><br><span class="line"></span><br><span class="line">    c-&gt;cancel_wait();</span><br><span class="line">    <span class="keyword">if</span>(local_txns.get&lt;by_id&gt;().find(tid) != local_txns.end()) &#123;</span><br><span class="line">        fc_dlog(logger, <span class="string">"got a duplicate transaction - dropping"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatcher-&gt;recv_transaction(c, tid);</span><br><span class="line">    <span class="comment">// 验证交易</span></span><br><span class="line">    chain_plug-&gt;accept_transaction(ptrx, [c, <span class="keyword">this</span>, ptrx](<span class="keyword">const</span> static_variant&lt;fc::exception_ptr, transaction_trace_ptr&gt;&amp; result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.contains&lt;fc::exception_ptr&gt;()) &#123;</span><br><span class="line">        peer_dlog(c, <span class="string">"bad packed_transaction : $&#123;m&#125;"</span>, (<span class="string">"m"</span>,result.get&lt;fc::exception_ptr&gt;()-&gt;what()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> trace = result.get&lt;transaction_trace_ptr&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!trace-&gt;except) &#123;</span><br><span class="line">            fc_dlog(logger, <span class="string">"chain accepted transaction"</span>);</span><br><span class="line">            <span class="comment">// 广播交易</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;dispatcher-&gt;bcast_transaction(ptrx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        peer_elog(c, <span class="string">"bad packed_transaction : $&#123;m&#125;"</span>, (<span class="string">"m"</span>,trace-&gt;except-&gt;what()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拒绝交易</span></span><br><span class="line">        dispatcher-&gt;rejected_transaction(ptrx-&gt;id);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，net_plugin以及net_plugin_impl插件中的比较重要的函数已经分析完毕，由于其中细节错综复杂，因此在分析过程中抓住主要脉络进行分析，对于其他细节内容并没有深究。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/03/28/EOS中plugin之chain_plugin/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/28/EOS中plugin之chain_plugin/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">EOS中plugin之chain_plugin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-28 14:15:24" itemprop="dateCreated datePublished" datetime="2019-03-28T14:15:24+08:00">2019-03-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-04-08 22:30:44" itemprop="dateModified" datetime="2019-04-08T22:30:44+08:00">2019-04-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/03/26/2018~2019年上下半学期学习计划/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/2018~2019年上下半学期学习计划/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">2018~2019年上下半学期学习计划</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-26 16:19:00 / 更新于：18:10:01" itemprop="dateCreated datePublished" datetime="2019-03-26T16:19:00+08:00">2019-03-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h1><h2 id="1-区块链匿名性方面论文阅读"><a href="#1-区块链匿名性方面论文阅读" class="headerlink" title="1. 区块链匿名性方面论文阅读"></a>1. 区块链匿名性方面论文阅读</h2><h3 id="总目标：对匿名性研究方面有比较深入的了解"><a href="#总目标：对匿名性研究方面有比较深入的了解" class="headerlink" title="总目标：对匿名性研究方面有比较深入的了解"></a>总目标：对匿名性研究方面有比较深入的了解</h3><h3 id="量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊"><a href="#量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊" class="headerlink" title="量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊"></a>量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊</h3><h3 id="进度情况"><a href="#进度情况" class="headerlink" title="进度情况"></a>进度情况</h3><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>论文</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2019年3月17日</td>
<td>An Empirical Analysis of Anonymity in Zcash</td>
<td>完成</td>
</tr>
<tr>
<td>2019年3月24日</td>
<td>Extending the Anonymity of Zcash</td>
<td>完成</td>
</tr>
<tr>
<td>2019年3月30日</td>
<td>A Traceability Analysis of Monero’s Blockchain</td>
<td>进行中</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-日志异常检测工作"><a href="#2-日志异常检测工作" class="headerlink" title="2. 日志异常检测工作"></a>2. 日志异常检测工作</h2><h3 id="总目标：实现系统日志异常检测"><a href="#总目标：实现系统日志异常检测" class="headerlink" title="总目标：实现系统日志异常检测"></a>总目标：实现系统日志异常检测</h3><h3 id="进度情况-1"><a href="#进度情况-1" class="headerlink" title="进度情况"></a>进度情况</h3><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>任务</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2019年3月17日</td>
<td>DeepLog论文思路理解</td>
<td>完成</td>
</tr>
<tr>
<td>2019年3月24日</td>
<td>实现execute path anomaly detection</td>
<td>完成</td>
</tr>
<tr>
<td>2019年3月30日</td>
<td>实现 parameters anomaly detection</td>
<td>进行</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-EOS源码阅读计划"><a href="#3-EOS源码阅读计划" class="headerlink" title="3. EOS源码阅读计划"></a>3. EOS源码阅读计划</h2><h3 id="总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解"><a href="#总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解" class="headerlink" title="总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解"></a>总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解</h3><h3 id="量化方式：阅读源代码并撰写笔记"><a href="#量化方式：阅读源代码并撰写笔记" class="headerlink" title="量化方式：阅读源代码并撰写笔记"></a>量化方式：阅读源代码并撰写笔记</h3><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>源码部分</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>3月10日~截止3月17日</td>
<td>produccer_plugin类、abstract_plugin类</td>
<td>已掌握</td>
</tr>
<tr>
<td>3月18日~</td>
<td>producer_plugin_impl类</td>
<td>进行中</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/03/26/科研计划/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/26/科研计划/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">2018~2019年上下半学期学习计划</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-26 16:19:00" itemprop="dateCreated datePublished" datetime="2019-03-26T16:19:00+08:00">2019-03-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-04-08 17:09:32" itemprop="dateModified" datetime="2019-04-08T17:09:32+08:00">2019-04-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h1><h2 id="1-区块链匿名性方面论文阅读"><a href="#1-区块链匿名性方面论文阅读" class="headerlink" title="1. 区块链匿名性方面论文阅读"></a>1. 区块链匿名性方面论文阅读</h2><h3 id="总目标：对匿名性研究方面有比较深入的了解"><a href="#总目标：对匿名性研究方面有比较深入的了解" class="headerlink" title="总目标：对匿名性研究方面有比较深入的了解"></a>总目标：对匿名性研究方面有比较深入的了解</h3><h3 id="量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊"><a href="#量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊" class="headerlink" title="量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊"></a>量化方式：总结出匿名性方面的研究给出目前的主要研究方向以及方法，主要发表的期刊</h3><h3 id="进度情况"><a href="#进度情况" class="headerlink" title="进度情况"></a>进度情况</h3><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>论文</th>
<th>理解撰写阅读报告</th>
</tr>
</thead>
<tbody>
<tr>
<td>2019年3月17日</td>
<td>An Empirical Analysis of Anonymity in Zcash</td>
<td>已完成</td>
</tr>
<tr>
<td>2019年3月24日</td>
<td>Extending the Anonymity of Zcash</td>
<td>已完成</td>
</tr>
<tr>
<td>2019年3月30日</td>
<td>A Traceability Analysis of Monero’s Blockchain</td>
<td>已完成</td>
</tr>
<tr>
<td>2019年4月7日</td>
<td>New Empirical Traceability Analysis of CryptoNote-Style Blockchains</td>
<td>已完成</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-日志异常检测工作"><a href="#2-日志异常检测工作" class="headerlink" title="2. 日志异常检测工作"></a>2. 日志异常检测工作</h2><h3 id="总目标：实现系统日志异常检测"><a href="#总目标：实现系统日志异常检测" class="headerlink" title="总目标：实现系统日志异常检测"></a>总目标：实现系统日志异常检测</h3><h3 id="进度情况-1"><a href="#进度情况-1" class="headerlink" title="进度情况"></a>进度情况</h3><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>任务</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2019年3月17日</td>
<td>DeepLog论文思路理解</td>
<td>完成</td>
</tr>
<tr>
<td>2019年3月24日</td>
<td>实现execute path anomaly detection</td>
<td>完成</td>
</tr>
<tr>
<td>2019年3月30日</td>
<td>实现 parameters anomaly detection</td>
<td>进行</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-EOS源码阅读计划"><a href="#3-EOS源码阅读计划" class="headerlink" title="3. EOS源码阅读计划"></a>3. EOS源码阅读计划</h2><h3 id="总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解"><a href="#总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解" class="headerlink" title="总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解"></a>总目标：本学期结束时需对EOS中区块生产过程、用户交易发起到上链过程等重要过程有深入的理解</h3><h3 id="量化方式：阅读源代码并撰写笔记"><a href="#量化方式：阅读源代码并撰写笔记" class="headerlink" title="量化方式：阅读源代码并撰写笔记"></a>量化方式：阅读源代码并撰写笔记</h3><div class="table-container">
<table>
<thead>
<tr>
<th>时间</th>
<th>源码部分</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>3月10日~3月17日</td>
<td>produccer_plugin类、abstract_plugin类</td>
<td>已完成</td>
</tr>
<tr>
<td>3月18日~3月30日</td>
<td>producer_plugin_impl类</td>
<td>已完成</td>
</tr>
<tr>
<td>3月31日~4月13日</td>
<td>net_plugin / net_plugin_impl类</td>
<td>进行中</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/03/20/EOS中plugin之producer_plugin/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/20/EOS中plugin之producer_plugin/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">EOS中plugin之producer_plugin</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-20 18:29:54" itemprop="dateCreated datePublished" datetime="2019-03-20T18:29:54+08:00">2019-03-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-04-08 22:31:20" itemprop="dateModified" datetime="2019-04-08T22:31:20+08:00">2019-04-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="EOS中plugin之producer-plugin"><a href="#EOS中plugin之producer-plugin" class="headerlink" title="EOS中plugin之producer_plugin"></a>EOS中plugin之producer_plugin</h1><p>EOS中的插件是非常重要的工具，其中大大小小总共有26个插件，其中比较重要的插件有chain_plugin、producer_plugin、http_plugin、net_plugin等四个插件。这四个插件在EOS服务器端启动后也开始启动进行工作。</p>
<h2 id="abstract-plugin"><a href="#abstract-plugin" class="headerlink" title="abstract_plugin"></a>abstract_plugin</h2><p>EOS中所有插件继承于plugin类，而plugin类又继承于abstract_plugin类。<br>abstract_plugin中规定了每个插件的4个状态，这4个状态依次如下。</p>
<ul>
<li>registered，表示插件已经注册， 每个插件初始化后就是注册的状态。</li>
<li>initialized，表示插件已经初始化，插件之后注册之后才能初始化。</li>
<li>started， 表示插件正在运行中。</li>
<li>stopped，表示插件停止运行。</li>
</ul>
<p>下面是abstract_plugin的源代码，由于是个抽象类，abstract_plugin定义在appbase\appbase\plugin.hpp中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract_plugin</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 插件的4个状态。</span></span><br><span class="line">        <span class="keyword">enum</span> state &#123;</span><br><span class="line">        registered, <span class="comment">///&lt; the plugin is constructed but doesn't do anything</span></span><br><span class="line">        initialized, <span class="comment">///&lt; the plugin has initialized any state required but is idle</span></span><br><span class="line">        started, <span class="comment">///&lt; the plugin is actively running</span></span><br><span class="line">        stopped <span class="comment">///&lt; the plugin is no longer running</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~abstract_plugin()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> state <span class="title">get_state</span><span class="params">()</span><span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 查询插件当前的状态</span></span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span><span class="keyword">const</span>  </span>= <span class="number">0</span>;    <span class="comment">// 获取插件名称</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_program_options</span><span class="params">( options_description&amp; cli, options_description&amp; cfg )</span> </span>= <span class="number">0</span>;                 <span class="comment">// 设置插件参数</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">const</span> variables_map&amp; options)</span> </span>= <span class="number">0</span>;<span class="comment">//初始化插件</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle_sighup</span><span class="params">()</span> </span>= <span class="number">0</span>;               <span class="comment">// 这个干嘛用的不清楚</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>= <span class="number">0</span>;                     <span class="comment">// 启动插件</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>= <span class="number">0</span>;                    <span class="comment">// 关闭插件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>plugin这个类继承了abstract_plugin，plugin的代码在appbase\apppbase\apllication.hpp中，这里比较奇怪的是，为什么plugin的定义不再plugin.hpp文件中，而plugin.hpp中定义了abstract_plugin类。</p>
<p>plugin是一个模板类，在plugin中，除去handle_sighup函数之外，已经实现了abstract_plugin中的全部纯虚函数。handle_sighup函数的含义，目前我不太清楚。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Impl&gt;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">plugin</span> :</span> <span class="keyword">public</span> abstract_plugin &#123;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">         plugin():_name(boost::core::demangle(<span class="keyword">typeid</span>(Impl).name()))&#123;&#125;</span><br><span class="line">         <span class="keyword">virtual</span> ~plugin()&#123;&#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> state <span class="title">get_state</span><span class="params">()</span><span class="keyword">const</span> override         </span>&#123; <span class="keyword">return</span> _state; &#125;</span><br><span class="line">         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">name</span><span class="params">()</span><span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> _name; &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">register_dependencies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;plugin_requires([&amp;](<span class="keyword">auto</span>&amp; plug)&#123;&#125;);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">const</span> variables_map&amp; options)</span> override </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == registered) &#123;</span><br><span class="line">               _state = initialized;</span><br><span class="line">               <span class="keyword">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;plugin_requires([&amp;](<span class="keyword">auto</span>&amp; plug)&#123; plug.initialize(options); &#125;);</span><br><span class="line">               <span class="keyword">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;plugin_initialize(options);</span><br><span class="line">               <span class="comment">//ilog( "initializing plugin $&#123;name&#125;", ("name",name()) );</span></span><br><span class="line">               app().plugin_initialized(*<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            assert(_state == initialized); <span class="comment">/// if initial state was not registered, final state cannot be initialized</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handle_sighup</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 插件启动函数</span></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == initialized) &#123;</span><br><span class="line">               _state = started;</span><br><span class="line">               <span class="keyword">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;plugin_requires([&amp;](<span class="keyword">auto</span>&amp; plug)&#123; plug.startup(); &#125;);</span><br><span class="line">               <span class="keyword">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;plugin_startup();</span><br><span class="line">               app().plugin_started(*<span class="keyword">this</span>);     <span class="comment">// </span></span><br><span class="line">            &#125;</span><br><span class="line">            assert(_state == started); <span class="comment">// if initial state was not initialized, final state cannot be started</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_state == started) &#123;</span><br><span class="line">               _state = stopped;</span><br><span class="line">               <span class="comment">//ilog( "shutting down plugin $&#123;name&#125;", ("name",name()) );</span></span><br><span class="line">               <span class="keyword">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;plugin_shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">protected</span>:</span><br><span class="line">         plugin(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name) : _name(name)&#123;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">         state _state = abstract_plugin::registered;</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">string</span> _name;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<p>首先可以看到plugin的初始化函数，由于plugin是一个模板类，在初始化过程中，传入的模板类的名称赋值给了plugin的protected变量_name，里面唯一不太理解的是，为什么这个_name是protected的类型而不是private类型。typeid在头文件typeindex中，主要是获得某个类的名称。</p>
<p>此外，plugin中实现了插件的startup()、initialized()和shutdown()三个功能。在initialize()函数中，首先判断当前状态是否是registered状态，随后更改状态为initialized状态，然后查询当前插件依赖的其他插件并且将其他插件初始化，随后初始化插件自身。注意到插件启动完成后有如下一句代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app().plugin_initialized(*<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>app()函数返回客户端的引用，随后客户端将当前初始化的插件变量放入到当前客户端中已初始化插件的vector中。</p>
<p>在startup()之前，可以看到，插件启动之前，其状态必须是已经初始化的状态，这表明插件启动之前必须初始化。随后设置状态为启动状态。然后查询当前插件启动需要的其他插件并启动这些插件，随后再启动插件自身，随后客户端将当前已启动的插件变量放入到当前客户端中已启动插件的vector中。</p>
<p>在shutdown()函数中，特别厉害的一个设计就是关闭插件的调用，因为不同的插件，可能关闭方式不一样，但是在plugin中仍然也实现了这个方法，实在是太巧妙了。最精髓的就是这句代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;Impl*&gt;(<span class="keyword">this</span>)-&gt;plugin_shutdown();</span><br></pre></td></tr></table></figure></p>
<p>将当前指针转换成模板类初始化时传进的类，然后调用这个类的plugin_shutdown()函数。好像很牛批，可是我仔细一想，最后不还是调用每个类自己的plugin_shutdown()函数了吗，每个类中自己实现这个功能好像也可以，这样设计就是看起来很牛批，但是没什么卵用，奇技淫巧而已~</p>
<p>现在介绍下EOS具体的插件，producer_plugin，这个插件主要负责超级节点的区块生产、同步以及新区快的校验工作，是4个插件里面最重要的一个插件。</p>
<h2 id="producer-plugin"><a href="#producer-plugin" class="headerlink" title="producer_plugin"></a>producer_plugin</h2><h3 id="（1）-producer-plugin-hpp"><a href="#（1）-producer-plugin-hpp" class="headerlink" title="（1）. producer_plugin.hpp"></a>（1）. producer_plugin.hpp</h3><p>producer_plugin插件的实现位于plugins\producer_plugin下。producer_plugin类的定义，就很头铁，定义方式如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">producer_plugin</span> :</span> <span class="keyword">public</span> appbase::plugin&lt;producer_plugin&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在定义的过程中就传入了producer_plugin的类名，这个名称会传给plugin中的_name变量。<br>为什么会有appbase这个玩意儿呢，因为这是一个命名空间，plugin就定义在appbase命名空间中。</p>
<p>接下来我们看看producer_plugin的头文件，由于头文件比较长，口味略重，非战斗人员请迅速撤离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">producer_plugin</span> :</span> <span class="keyword">public</span> appbase::plugin&lt;producer_plugin&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   APPBASE_PLUGIN_REQUIRES((chain_plugin)(http_client_plugin))</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">runtime_options</span> &#123;</span></span><br><span class="line">      fc::optional&lt;<span class="keyword">int32_t</span>&gt; max_transaction_time;</span><br><span class="line">      fc::optional&lt;<span class="keyword">int32_t</span>&gt; max_irreversible_block_age;</span><br><span class="line">      fc::optional&lt;<span class="keyword">int32_t</span>&gt; produce_time_offset_us;</span><br><span class="line">      fc::optional&lt;<span class="keyword">int32_t</span>&gt; last_block_time_offset_us;</span><br><span class="line">      fc::optional&lt;<span class="keyword">int32_t</span>&gt; max_scheduled_transaction_time_per_block_ms;</span><br><span class="line">      fc::optional&lt;<span class="keyword">int32_t</span>&gt; subjective_cpu_leeway_us;</span><br><span class="line">      fc::optional&lt;<span class="keyword">double</span>&gt;  incoming_defer_ratio;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">whitelist_blacklist</span> &#123;</span></span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; actor_whitelist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; actor_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; contract_whitelist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;account_name&gt; &gt; contract_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt; <span class="built_in">std</span>::pair&lt;account_name, action_name&gt; &gt; &gt; action_blacklist;</span><br><span class="line">      fc::optional&lt; flat_set&lt;public_key_type&gt; &gt; key_blacklist;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">greylist_params</span> &#123;</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;account_name&gt; accounts;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">integrity_hash_information</span> &#123;</span></span><br><span class="line">      chain::block_id_type head_block_id;</span><br><span class="line">      chain::digest_type   integrity_hash;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">snapshot_information</span> &#123;</span></span><br><span class="line">      chain::block_id_type head_block_id;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span>          snapshot_name;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   producer_plugin();</span><br><span class="line">   <span class="keyword">virtual</span> ~producer_plugin();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">set_program_options</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      boost::program_options::options_description &amp;command_line_options,</span></span></span><br><span class="line"><span class="function"><span class="params">      boost::program_options::options_description &amp;config_file_options</span></span></span><br><span class="line"><span class="function"><span class="params">      )</span> override</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断一个公钥是否是当前区块生产者的公钥</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span>                   <span class="title">is_producer_key</span><span class="params">(<span class="keyword">const</span> chain::public_key_type&amp; key)</span> <span class="keyword">const</span></span>; </span><br><span class="line">   <span class="comment">// 应该是对摘要进行签名，这里面的key应该是私钥。        </span></span><br><span class="line">   chain::<span class="function">signature_type  <span class="title">sign_compact</span><span class="params">(<span class="keyword">const</span> chain::public_key_type&amp; key, <span class="keyword">const</span> fc::sha256&amp; digest)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对插件进行初始化</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">plugin_initialize</span><span class="params">(<span class="keyword">const</span> boost::program_options::variables_map&amp; options)</span></span>;</span><br><span class="line">   <span class="comment">// 插件启动函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">plugin_startup</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 插件关闭函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">plugin_shutdown</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 暂停运行和继续运行</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 返回插件是否被暂停的状态</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">paused</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新运行的相关参数</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">update_runtime_options</span><span class="params">(<span class="keyword">const</span> runtime_options&amp; options)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取运行时的相关参数</span></span><br><span class="line">   <span class="function">runtime_options <span class="title">get_runtime_options</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 增加grey_list</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">add_greylist_accounts</span><span class="params">(<span class="keyword">const</span> greylist_params&amp; params)</span></span>;</span><br><span class="line">   <span class="comment">// 删除grey_list</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">remove_greylist_accounts</span><span class="params">(<span class="keyword">const</span> greylist_params&amp; params)</span></span>;</span><br><span class="line">   <span class="comment">// 获取greylist</span></span><br><span class="line">   <span class="function">greylist_params <span class="title">get_greylist</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取whitelist和设置whitelist</span></span><br><span class="line">   <span class="function">whitelist_blacklist <span class="title">get_whitelist_blacklist</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">set_whitelist_blacklist</span><span class="params">(<span class="keyword">const</span> whitelist_blacklist&amp; params)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取integrity_hash_information</span></span><br><span class="line">   <span class="function">integrity_hash_information <span class="title">get_integrity_hash</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 创建一个快照，snapshot中文意思是快照</span></span><br><span class="line">   <span class="function">snapshot_information <span class="title">create_snapshot</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义一个返回值为空，传入变量为const chain::producer_confirmation&amp;的signal</span></span><br><span class="line">   <span class="comment">// 这个信号用于区块的确认。</span></span><br><span class="line">   signal&lt;<span class="keyword">void</span>(<span class="keyword">const</span> chain::producer_confirmation&amp;)&gt; confirmed_block;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// producer_plugin_impl的指针,负责所有任务的执行</span></span><br><span class="line">    <span class="comment">// producer_plugin_impl类的定义在producer_plugin.cpp中</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">producer_plugin_impl</span>&gt; <span class="title">my</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>producer_plugin定义完毕之后第一个public函数就很恶心咯，这是什么鬼!!!仔细看看这些大写字母的定义，转换成小写字母，即appbase_plugin_requires,还记得前面说每个插件初始化或者启动的时候都要初始化或者启动它依赖的插件这个过程吗？这感觉应该是说producer_plugin类启动的时候依赖chain_plugin和http_client_plugin两个插件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPBASE_PLUGIN_REQUIRES((chain_plugin)(http_client_plugin))</span><br></pre></td></tr></table></figure></p>
<p>大写的显示，应该是说明这一个宏定义，果然，我们翻了一下，宏定义在plugin.hpp文件中，具体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APPBASE_PLUGIN_REQUIRES( PLUGINS )                               \</span></span><br><span class="line">   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lambda&gt;                                           \</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">plugin_requires</span><span class="params">( Lambda&amp;&amp; l )</span> </span>&#123;                                \</span><br><span class="line">      BOOST_PP_SEQ_FOR_EACH( APPBASE_PLUGIN_REQUIRES_VISIT, l, PLUGINS ) \</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APPBASE_PLUGIN_REQUIRES_VISIT( r, visitor, elem ) \</span></span><br><span class="line">  visitor( appbase::app().register_plugin&lt;elem&gt;() )</span><br></pre></td></tr></table></figure>
<p>哇~~~，越来越恶心了,这个宏定义，指向一个模板函数，这个模板函数的参数是一个函数，里面用到了BOOST_PP_SEQ_FOR_EACH，这个一般如下用法：</p>
<ul>
<li>BOOST_PP_SEQ_FOR_EACH(macro, r, data)</li>
<li>macro，一个以格式macro(r, data, elem)定义的三元宏。该宏被BOOST_PP_SEQ_FOR_EACH按照seq中每个元素进行展开。展开该宏，需要用到下一个BOOST_PP_FOR的重复项、备用数据data和当前元素。</li>
<li>data，备用数据，用于传给macro。</li>
<li>seq，用于供macro按照哪个序列进行展开。</li>
</ul>
<p>具体的细节尚未弄清楚，但是明确的是，这个hpp文件可以看出producer_plugin插件依赖两个插件，即chain_plugin和http_client_plugin。</p>
<p>随后再producer_plugin中定义了一系列结构体。这些结构体都用到了一个optional的类。简单地来说，这个类类似于boost::optional的概念，主要用于实现未初始化的概念。函数并不能总是返回有意义的结果，有时候函数可能返回“无意义”的值，一般来说我们通常使用一个不再正常解空间的一个哨兵来表示无意义的概念，如NULL，-1，end()或者EOF.然后对于不同的应用场合，这些哨兵并不是通用的，而且有时候可能不存在这种解空间之外的哨兵。optional很像一个仅能存放一个元素的容器，它实现了”未初始化”的概念：如果元素未初始化，那么容器就是空的，否则，容器内就是有效的，已经初始化的值。optional的真实接口很复杂，因为它要能包装任何的类型。</p>
<p>定义的这些结构体，我想应该是producer_plugin运行时配置的一些参数，大致知道这个概念即可。随后是producer_plugin的构造函数、析构函数以及设置参数的函数。更加详细的内容，我已经写在注释中，可以参看，至于producer_plugin中一些方法的具体实现，暂时不予理会，知道其作用就可以了。</p>
<h3 id="（2）-plugin-startup"><a href="#（2）-plugin-startup" class="headerlink" title="（2）. plugin_startup"></a>（2）. plugin_startup</h3><p>producer_plugin.cpp中插件的plugin_shutdown, pause, resume等函数不是很重要，因此这里不再介绍。但是中最重要的一个函数是plugin_startup函数，nodeos节点启动之后，启动producer_plugin插件的接口就是这个函数，这里需对这个函数进行详细的解析，但是我们仍然会跳过一些细枝末节的东西，重点看其主要脉络。由于源码中这个函数内容比较多，这里不再展示源码，直接从主要流程开始。</p>
<p>在函数里面首先获取一个变量：chain<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chain::controller &amp;chain = my-&gt;chain-&gt;chain_plug-&gt;chain()</span><br></pre></td></tr></table></figure></p>
<p>my是一个produer_plugin_impl类的智能指针，这个指针具体负责交易的打包、区块的生产和检查等工作。通过chain可以访问到区块链上的一些信息。</p>
<p>随后chain连接两个信号量，分别执行的函数是on_block()和on_irreversible_block。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my-&gt;_accepted_block_connection.emplace(chain.accepted_block.connect([<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;bsp) &#123; my-&gt;on_block(bsp); &#125;));</span><br><span class="line">      my-&gt;_irreversible_block_connection.emplace(chain.irreversible_block.connect([<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;bsp) &#123; my-&gt;on_irreversible_block(bsp-&gt;block); &#125;));</span><br></pre></td></tr></table></figure></p>
<p>在boost中，进行connect之后返回一个connection的对象，my将返回的两个对象放入自己的connection容器中。</p>
<p>随后获得了区块链上最近的一个不可逆区块的块号和其指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> lib_num = chain.last_irreversible_block_num();<span class="comment">// 返回块号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> lib = chain.fetch_block_by_number(lib_num); <span class="comment">// 返回指针</span></span><br></pre></td></tr></table></figure></p>
<p>如果当前区块指针不为空，则进入my-&gt;on_irreversible_block(lib)函数。my-&gt;on_irreversible_block函数就是将不可逆区块的时间设置为lib指向的区块的时间。<br>如果lib指针为空，设置不可逆区块的时间为当前时间的最大值，即设置为0xffffffff秒，时间大致为139年，那时候BM应该早就跪了~</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lib)&#123;</span><br><span class="line">   my-&gt;on_irreversible_block(lib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">// maximum 大致是136年</span></span><br><span class="line">   my-&gt;_irreversible_block_time = fc::time_point::maximum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，判断my中的区块生产者列表是否为空，若当前节点可以生产区块，如果是第一次接入的超节点，则展示new_chain_banner标志。随后开始进入区块生产的大循环中，区块生产的函是由my控制的。看起来my这个插件无法避免的需要介绍了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my-&gt;_production_enabled)&#123;</span><br><span class="line">   <span class="keyword">if</span> (chain.head_block_num() == <span class="number">0</span>)</span><br><span class="line">   &#123; <span class="comment">// 如果是创世块，展示新区块的标语</span></span><br><span class="line">      new_chain_banner(chain);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//_production_skip_flags |= eosio::chain::skip_undo_history_check;</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">// 开始进入区块生产循环中,持续不断的开始生产区块</span></span><br><span class="line">   my-&gt;schedule_production_loop();</span><br></pre></td></tr></table></figure></p>
<p>至此，plugin_startup函数的主要情况已经介绍完毕，my-&gt;schedule_produetion_loop函数的介绍，将在produer_plugin_impl类的介绍中进行。</p>
<h2 id="producer-plugin-impl"><a href="#producer-plugin-impl" class="headerlink" title="producer_plugin_impl"></a>producer_plugin_impl</h2><h3 id="producer-plugin-impl类中的变量"><a href="#producer-plugin-impl类中的变量" class="headerlink" title="producer_plugin_impl类中的变量"></a>producer_plugin_impl类中的变量</h3><p>produer_plugin_impl类的定义，上来我就懵逼了，这是什么！！！enable_shared_from_this也是一个类，但是这种继承的形式到底是怎么肥四？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">producer_plugin_impl</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;producer_plugin_impl&gt;</span><br></pre></td></tr></table></figure>
<p>查了一下网上的解释，enable_shared_from_this是c++ 11的新特性，使用这个特性就可以获得一个对象的多个shared_ptr指针，但是又不会造成对象的多次释放问题。具体的解释可以参看下面两个链接：</p>
<p><a href="https://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this" target="_blank" rel="noopener">stack overflow</a></p>
<p><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this" target="_blank" rel="noopener">cpp reference</a></p>
<p>其初始化函数只有1个，里面_timer完成io操作，_transaction_ack_channel主要接收交易，具体形式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  producer_plugin_impl(boost::asio::io_service &amp;io)</span><br><span class="line">      : _timer(io), _transaction_ack_channel(app().get_channel&lt;compat::channels::transaction_ack&gt;())&#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>老实说，produer_plugin_impl中定义的变量很多，这些变量都是public属性。因为这个类具体负责区块生产，因此涉及到的事务非常繁杂，所以变量比较多也算正常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">optional&lt;fc::time_point&gt; calculate_next_block_time(<span class="keyword">const</span> account_name &amp;producer_name, <span class="keyword">const</span> block_timestamp_type &amp;current_block_time) <span class="keyword">const</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule_production_loop</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produce_block</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">maybe_produce_block</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">boost::program_options::variables_map _options;  <span class="comment">// 程序启动的一些选项</span></span><br><span class="line"><span class="keyword">bool</span> _production_enabled = <span class="literal">false</span>;   <span class="comment">//能够生产区块</span></span><br><span class="line"><span class="keyword">bool</span> _pause_production = <span class="literal">false</span>;     <span class="comment">// 是否暂停生产</span></span><br><span class="line"><span class="keyword">uint32_t</span> _production_skip_flags = <span class="number">0</span>; <span class="comment">//eosio::chain::skip_nothing;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是啥玩意，我不明白</span></span><br><span class="line"><span class="keyword">using</span> signature_provider_type = <span class="built_in">std</span>::function&lt;chain::signature_type(chain::digest_type)&gt;; </span><br><span class="line"><span class="comment">// 映射公钥和签名</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;chain::public_key_type, signature_provider_type&gt; _signature_providers;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;chain::account_name&gt; _producers; <span class="comment">// BP名单</span></span><br><span class="line">boost::asio::deadline_timer _timer;       <span class="comment">// 负责io的_timer</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;chain::account_name, <span class="keyword">uint32_t</span>&gt; _producer_watermarks;  <span class="comment">// BP的水印</span></span><br><span class="line">pending_block_mode _pending_block_mode;                        <span class="comment">// 添加区块的模式，producing和speculate两个模式</span></span><br><span class="line">transaction_id_with_expiry_index _persistent_transactions;     <span class="comment">// 过期的交易</span></span><br><span class="line">fc::optional&lt;boost::asio::thread_pool&gt; _thread_pool;           <span class="comment">// 线程池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int32_t</span> _max_transaction_time_ms;                              <span class="comment">// 交易的延迟时间</span></span><br><span class="line">fc::microseconds _max_irreversible_block_age_us;</span><br><span class="line"><span class="comment">// 非最后一个区块产生时间的偏移量，按微秒计算。负值会导致块更早出去，正值会导致块更晚出去。</span></span><br><span class="line"><span class="keyword">int32_t</span> _produce_time_offset_us = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 最后一个区块产生时间的偏移量，按微秒计算。负值会导致块更早出去，正值会导致块更晚出去。</span></span><br><span class="line"><span class="keyword">int32_t</span> _last_block_time_offset_us = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int32_t</span> _max_scheduled_transaction_time_per_block_ms;          <span class="comment">// 一个区块全部交易打包完毕的最大时间耗费</span></span><br><span class="line"></span><br><span class="line">fc::time_point _irreversible_block_time;                       <span class="comment">// 不可逆区块的时间</span></span><br><span class="line">fc::microseconds _keosd_provider_timeout_us;                   <span class="comment">// 钱包客户端超时时间 us为单位</span></span><br><span class="line"></span><br><span class="line">time_point _last_signed_block_time;                            <span class="comment">// 最近一个签名区块的时间</span></span><br><span class="line">time_point _start_time = fc::time_point::now();                <span class="comment">// 启动时间，当前时间</span></span><br><span class="line"><span class="keyword">uint32_t</span> _last_signed_block_num = <span class="number">0</span>;                           <span class="comment">// 最近一个签名区块的块号</span></span><br><span class="line"></span><br><span class="line">producer_plugin *_self = <span class="literal">nullptr</span>;                              <span class="comment">// 指向producer_plugin的指针</span></span><br><span class="line">chain_plugin *chain_plug = <span class="literal">nullptr</span>;                            <span class="comment">// 指向chain_plugin的指针</span></span><br><span class="line"></span><br><span class="line">incoming::channels::block::channel_type::handle _incoming_block_subscription; <span class="comment">// 订阅收到的区块？</span></span><br><span class="line">incoming::channels::transaction::channel_type::handle _incoming_transaction_subscription; <span class="comment">// 订阅收到交易？</span></span><br><span class="line"></span><br><span class="line">compat::channels::transaction_ack::channel_type &amp;_transaction_ack_channel;    <span class="comment">// 接收交易的通道</span></span><br><span class="line"></span><br><span class="line">incoming::methods::block_sync::method_type::handle _incoming_block_sync_provider;   <span class="comment">// 同步区块的数据提供方</span></span><br><span class="line">incoming::methods::transaction_async::method_type::handle _incoming_transaction_async_provider; <span class="comment">// 同步交易的数据提供方</span></span><br><span class="line"></span><br><span class="line">transaction_id_with_expiry_index _blacklisted_transactions;       <span class="comment">// 超时交易的id</span></span><br><span class="line"></span><br><span class="line">fc::optional&lt;scoped_connection&gt; _accepted_block_connection;       <span class="comment">// 存储已经接收区块的connection</span></span><br><span class="line">fc::optional&lt;scoped_connection&gt; _irreversible_block_connection;   <span class="comment">// 存储不可逆区块的connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * HACK ALERT</span></span><br><span class="line"><span class="comment">      * Boost timers can be in a state where a handler has not yet executed but is not abortable.</span></span><br><span class="line"><span class="comment">      * As this method needs to mutate state handlers depend on for proper functioning to maintain</span></span><br><span class="line"><span class="comment">      * invariants for other code (namely accepting incoming transactions in a nearly full block)</span></span><br><span class="line"><span class="comment">      * the handlers capture a corelation ID at the time they are set.  When they are executed</span></span><br><span class="line"><span class="comment">      * they must check that correlation_id against the global ordinal.  If it does not match that</span></span><br><span class="line"><span class="comment">      * implies that this method has been called with the handler in the state where it should be</span></span><br><span class="line"><span class="comment">      * cancelled but wasn't able to be.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="keyword">uint32_t</span> _timer_corelation_id = <span class="number">0</span>;                        </span><br><span class="line"></span><br><span class="line"><span class="comment">// keep a expected ratio between defer txn and incoming txn</span></span><br><span class="line"><span class="keyword">double</span> _incoming_trx_weight = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> _incoming_defer_ratio = <span class="number">1.0</span>; <span class="comment">// 1:1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// path to write the snapshots to</span></span><br><span class="line">bfs::path _snapshots_dir;</span><br></pre></td></tr></table></figure>
<p>可能会奇怪，为什么my指针中的变量，在其初始化函数中都没有看到初始化的工作，例如其中的chain_plugin和producer_plugin指针。实际上，my中这些变量的初始化工作已经在producer_plugin的initialized函数中初始化完毕了。</p>
<h3 id="schedule-production-loop-函数"><a href="#schedule-production-loop-函数" class="headerlink" title="schedule_production_loop 函数"></a>schedule_production_loop 函数</h3><p>producer_plugin的startup函数中就是调用了producer_plugin_impl中的shcedule_production_loop函数开始生产区块。因此，我们首先从这个函数入手，开始分析producer_plugin_impl是如何生产区块的。</p>
<p>函数首先获得了chain的引用和指向producer_plugin_impl的一个weak_ptr指针，关闭了_timer的io操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chain::controller &amp;chain = chain_plug-&gt;chain();</span><br><span class="line">_timer.cancel(); <span class="comment">// _timer 是boost库中asio的一个定时器,关闭所有异步等待</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;producer_plugin_impl&gt; weak_this = shared_from_this();</span><br><span class="line"><span class="keyword">auto</span> result = start_block()</span><br></pre></td></tr></table></figure>
<p>随后尝试生产区块，调用了start_block函数，start_block函数返回结果有succeed,failed,waiting,exhausted4种，针对4中情况分别执行不用的流程。</p>
<ol>
<li><p>failed， 获取各种调度信息异常，则重新获取数据进行调度；</p>
</li>
<li><p>waitting，其它节点正在出块，则进行等待；</p>
</li>
<li><p>producing，轮到本节点出块，则进行出块操作；</p>
</li>
<li><p>succeed，生产区块成功，计算下一个生产者出块的时间。</p>
</li>
</ol>
<p>当start_block()返回结果为failed的时，进入异步等待状态，稍后再尝试生产区块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (result == start_block_result::failed)</span><br><span class="line">&#123;</span><br><span class="line">   elog(<span class="string">"Failed to start a pending block, will try again later"</span>);</span><br><span class="line">  </span><br><span class="line">   _timer.expires_from_now(boost::posix_time::microseconds(config::block_interval_us / <span class="number">10</span>)); <span class="comment">// 0.05秒后定时器失效</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 稍后继续尝试schedule_production_loop()函数</span></span><br><span class="line">   _timer.async_wait([weak_this, cid = ++_timer_corelation_id](<span class="keyword">const</span> boost::system::error_code &amp;ec) &#123;</span><br><span class="line">      <span class="comment">// 获得this的shared_ptr指针以判断是否被销毁，销毁返回空的shared_ptr</span></span><br><span class="line">      <span class="keyword">auto</span> self = weak_this.lock();</span><br><span class="line">      <span class="keyword">if</span> (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">      &#123;</span><br><span class="line">         self-&gt;schedule_production_loop();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果返回结果是waiting，表示本地的区块链还在从eos网络中下载区块已进行信息同步过程中，这个过程中还无法生产区块。随后查看当前是否还能继续生产区块，如果可以，则待会儿生产区块，即调用函数schedule_delayed_production_loop，这个函数这里不再进行仔细分析，主要就是过一段时间后这个函数中还会调用schedule_production_loop函数进行区块生产。<br> 返回结果时waiting的情况下，对应代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result == start_block_result::waiting)</span><br><span class="line">&#123; <span class="comment">// 当前还在同步区块信息,等待中...</span></span><br><span class="line">    <span class="comment">// waiting的状态有两种情况,要么生产区块的BP名单为空,或者是生产区块受外部命令而停止</span></span><br><span class="line">   <span class="keyword">if</span> (!_producers.empty() &amp;&amp; !production_disabled_by_policy())</span><br><span class="line">   &#123;</span><br><span class="line">      fc_dlog(_log, <span class="string">"Waiting till another block is received and scheduling Speculative/Production Change"</span>);</span><br><span class="line">      <span class="comment">// 过会儿再进行区块生产</span></span><br><span class="line">      schedule_delayed_production_loop(weak_this, calculate_pending_block_time());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      fc_dlog(_log, <span class="string">"Waiting till another block is received"</span>);</span><br><span class="line">      <span class="comment">// 其他区块还没有同步完毕,因此急需等待同步完成才能生产区块</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回结果是speculateing模式，并且还可以继续进行区块生产，但是生产者不确定这个区块是否合法，所以小心翼翼的过一会儿继续生产区块，过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_pending_block_mode == pending_block_mode::speculating &amp;&amp; !_producers.empty() &amp;&amp; !production_disabled_by_policy())</span><br><span class="line">&#123;</span><br><span class="line">   fc_dlog(_log, <span class="string">"Specualtive Block Created; Scheduling Speculative/Production Change"</span>);</span><br><span class="line">   EOS_ASSERT(chain.pending_block_state(), missing_pending_block_state, <span class="string">"speculating without pending_block_state"</span>);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pbs = chain.pending_block_state();</span><br><span class="line">   schedule_delayed_production_loop(weak_this, pbs-&gt;header.timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回结果是producing模式，表示已经成功的生产了一个区块，但是还需要其他一些验证工作。这里有个问题就是，为什么speculating模式下没有验证，非得在producing模式下验证生产的区块呢？</p>
<p>首先验证区块截止时间是否大于当前时间，如果大于当前时间，表明生产区块成功在截止日期内，是合法的区块，然后记录日志。如果截止日期超过现在，表明生产的区块已经过期了，此时将生产区块的时间减小0.5s，看是否超时并记录日志，这一步完成之后进行区块的同步操作。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_pending_block_mode == pending_block_mode::producing)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 成功打包了一个区块,但是得看看打包的区块是否超时</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> boost::posix_time::ptime epoch(boost::gregorian::date(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">   <span class="comment">// pending_block_time 返回最后一个区块的时间戳(是刚刚生产的区块的时间戳还是之前有效区块的时间戳,暂时还不清楚)</span></span><br><span class="line">   <span class="keyword">auto</span> deadline = calculate_block_deadline(chain.pending_block_time());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (deadline &gt; fc::time_point::now())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// ship this block off no later than its deadline</span></span><br><span class="line">      EOS_ASSERT(chain.pending_block_state(), missing_pending_block_state, <span class="string">"producing without pending_block_state, start_block succeeded"</span>);</span><br><span class="line">      _timer.expires_at(epoch + boost::posix_time::microseconds(deadline.time_since_epoch().count()));</span><br><span class="line">      fc_dlog(_log, <span class="string">"Scheduling Block Production on Normal Block #$&#123;num&#125; for $&#123;time&#125;"</span>, (<span class="string">"num"</span>, chain.pending_block_state()-&gt;block_num)(<span class="string">"time"</span>, deadline));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      EOS_ASSERT(chain.pending_block_state(), missing_pending_block_state, <span class="string">"producing without pending_block_state"</span>);</span><br><span class="line">      <span class="keyword">auto</span> expect_time = chain.pending_block_time() - fc::microseconds(config::block_interval_us);</span><br><span class="line">      <span class="comment">// ship this block off up to 1 block time earlier or immediately</span></span><br><span class="line">      <span class="keyword">if</span> (fc::time_point::now() &gt;= expect_time)</span><br><span class="line">      &#123;</span><br><span class="line">         _timer.expires_from_now(boost::posix_time::microseconds(<span class="number">0</span>));</span><br><span class="line">         fc_dlog(_log, <span class="string">"Scheduling Block Production on Exhausted Block #$&#123;num&#125; immediately"</span>, (<span class="string">"num"</span>, chain.pending_block_state()-&gt;block_num));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         _timer.expires_at(epoch + boost::posix_time::microseconds(expect_time.time_since_epoch().count()));</span><br><span class="line">         fc_dlog(_log, <span class="string">"Scheduling Block Production on Exhausted Block #$&#123;num&#125; at $&#123;time&#125;"</span>, (<span class="string">"num"</span>, chain.pending_block_state()-&gt;block_num)(<span class="string">"time"</span>, expect_time));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   _timer.async_wait([&amp;chain, weak_this, cid = ++_timer_corelation_id](<span class="keyword">const</span> boost::system::error_code &amp;ec) &#123;</span><br><span class="line">      <span class="keyword">auto</span> self = weak_this.lock();</span><br><span class="line">      <span class="keyword">if</span> (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">// pending_block_state expected, but can't assert inside async_wait</span></span><br><span class="line">         <span class="keyword">auto</span> block_num = chain.pending_block_state() ? chain.pending_block_state()-&gt;block_num : <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">auto</span> res = self-&gt;maybe_produce_block();</span><br><span class="line">         fc_dlog(_log, <span class="string">"Producing Block #$&#123;num&#125; returned: $&#123;res&#125;"</span>, (<span class="string">"num"</span>, block_num)(<span class="string">"res"</span>, res));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对其他一些细节的代码不太明白，也不必在意，因为我也不太清楚。但是我们注意到同步操作中的一段代码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_timer.async_wait(</span><br><span class="line">   [&amp;chain, weak_this, cid = ++_timer_corelation_id](const boost::system::error_code &amp;ec) &#123;</span><br><span class="line">   auto self = weak_this.lock();</span><br><span class="line">   if (self &amp;&amp; ec != boost::asio::error::operation_aborted &amp;&amp; cid == self-&gt;_timer_corelation_id)</span><br><span class="line">   &#123;</span><br><span class="line">      // pending_block_state expected, but can&apos;t assert inside async_wait</span><br><span class="line">      auto block_num = chain.pending_block_state() ? chain.pending_block_state()-&gt;block_num : 0;</span><br><span class="line">      auto res = self-&gt;maybe_produce_block();</span><br><span class="line">      fc_dlog(_log, &quot;Producing Block #$&#123;num&#125; returned: $&#123;res&#125;&quot;, (&quot;num&quot;, block_num)(&quot;res&quot;, res));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>_timer.async_wait应该是将生产出来的在群里面广播。这个函数接受一个lambda函数，表示同步的方法，同步过程中有一个maybe_produce_block()函数，我想应该是某个block procuder(以后简称BP)生产了一个区块，但是还没有得到其他BP的确认，这是个进行同步请求确认的过程。因此，我们再仔细看看进行同步的细节（不过貌似很多细节我也看不懂哎…囧…）。</p>
<p>mayb_produce_block函数的主要内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> producer_plugin_impl::maybe_produce_block()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">auto</span> reschedule = fc::make_scoped_exit([<span class="keyword">this</span>] &#123;</span><br><span class="line">      schedule_production_loop();</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         produce_block();</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (<span class="keyword">const</span> guard_exception &amp;e)</span><br><span class="line">      &#123;</span><br><span class="line">         chain_plug-&gt;handle_guard_exception(e);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      FC_LOG_AND_DROP();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (boost::interprocess::bad_alloc &amp;)</span><br><span class="line">   &#123;</span><br><span class="line">      raise(SIGUSR1);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fc_dlog(_log, <span class="string">"Aborting block due to produce_block error"</span>);</span><br><span class="line">   chain::controller &amp;chain = chain_plug-&gt;chain();</span><br><span class="line">   chain.abort_block();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上来就是一句我不懂的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> reschedule = fc::make_scoped_exit(</span><br><span class="line">   [<span class="keyword">this</span>]&#123;</span><br><span class="line">   schedule_production_loop();</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>也就是说，往里面传了一个lambda函数，函数就是重复生产区块的函数。但是fc::make_scope_exit又是什么意思呢？这里面大概介绍一下，make_scoped_exit函数中传入一个lambda函数，may_produe_block函数结束时reschedule函数只是定义了一下，reschedule隶属于scoped_exit类，这个类的析构函数中调用了schedule_production_loop();表明函数结束之后继续生产区块。<br>随后may_produce_block中有一个重要的函数，即produce_block()函数，我们继续追踪，这个函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> producer_plugin_impl::produce_block()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//ilog("produce_block $&#123;t&#125;", ("t", fc::time_point::now())); // for testing _produce_time_offset_us</span></span><br><span class="line">   EOS_ASSERT(_pending_block_mode == pending_block_mode::producing, producer_exception, <span class="string">"called produce_block while not actually producing"</span>);</span><br><span class="line">   </span><br><span class="line">   chain::controller &amp;chain = chain_plug-&gt;chain();</span><br><span class="line">   <span class="comment">// 获取当前打包好的区块的指针</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">auto</span> &amp;pbs = chain.pending_block_state();</span><br><span class="line">   <span class="comment">// 获取打包的区块的区块头</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">auto</span> &amp;hbs = chain.head_block_state();</span><br><span class="line">   EOS_ASSERT(pbs, missing_pending_block_state, <span class="string">"pending_block_state does not exist but it should, another plugin may have corrupted it"</span>);</span><br><span class="line">   <span class="comment">// 寻找BP的私钥</span></span><br><span class="line">   <span class="keyword">auto</span> signature_provider_itr = _signature_providers.find(pbs-&gt;block_signing_key);</span><br><span class="line"></span><br><span class="line">   EOS_ASSERT(signature_provider_itr != _signature_providers.end(), producer_priv_key_not_found, <span class="string">"Attempting to produce a block for which we don't have the private key"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//idump( (fc::time_point::now() - chain.pending_block_time()) );</span></span><br><span class="line">   <span class="comment">// 将区块内容写入数据库中，确定区块头中的merkel_root等内容</span></span><br><span class="line">   chain.finalize_block();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对区块进行签名</span></span><br><span class="line">   chain.sign_block([&amp;](<span class="keyword">const</span> digest_type &amp;d) &#123;</span><br><span class="line">      <span class="keyword">auto</span> debug_logger = maybe_make_debug_time_logger();</span><br><span class="line">      <span class="keyword">return</span> signature_provider_itr-&gt;second(d);</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">// 往本地的分叉的区块链数据库中提交区块，因为还没有确认</span></span><br><span class="line">   chain.commit_block();</span><br><span class="line">   <span class="comment">// 获取区块时间戳</span></span><br><span class="line">   <span class="keyword">auto</span> hbt = chain.head_block_time();</span><br><span class="line">   <span class="comment">//idump((fc::time_point::now() - hbt));</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取刚刚添加的最新的区块头状态</span></span><br><span class="line">   block_state_ptr new_bs = chain.head_block_state();</span><br><span class="line">   <span class="comment">// 记录最新的区块生产者和其生产的区块号</span></span><br><span class="line">   _producer_watermarks[new_bs-&gt;header.producer] = chain.head_block_num();</span><br><span class="line"></span><br><span class="line">   ilog(<span class="string">"Produced block $&#123;id&#125;... #$&#123;n&#125; @ $&#123;t&#125; signed by $&#123;p&#125; [trxs: $&#123;count&#125;, lib: $&#123;lib&#125;, confirmed: $&#123;confs&#125;]"</span>,</span><br><span class="line">        (<span class="string">"p"</span>, new_bs-&gt;header.producer)(<span class="string">"id"</span>, fc::variant(new_bs-&gt;id).as_string().substr(<span class="number">0</span>, <span class="number">16</span>))(<span class="string">"n"</span>, new_bs-&gt;block_num)(<span class="string">"t"</span>, new_bs-&gt;header.timestamp)(<span class="string">"count"</span>, new_bs-&gt;block-&gt;transactions.size())(<span class="string">"lib"</span>, chain.last_irreversible_block_num())(<span class="string">"confs"</span>, new_bs-&gt;header.confirmed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，大致对producer_plugin这个插件的内容以及主要功能有一个大致的了解。<br>这个插件主要负责区块的接收、检验、打包和本地写入功能。</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hzxGoForward.github.io/2019/03/14/An Empirical Analysis of Anonymity in Zcash/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="博主">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hzx's Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/14/An Empirical Analysis of Anonymity in Zcash/" class="post-title-link" itemprop="https://hzxGoForward.github.io/index.html">An Empirical Analysis of Anonymity in Zcash</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建于：2019-03-14 18:02:14" itemprop="dateCreated datePublished" datetime="2019-03-14T18:02:14+08:00">2019-03-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="更新于：2019-04-08 22:40:06" itemprop="dateModified" datetime="2019-04-08T22:40:06+08:00">2019-04-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/区块链技术研究/" itemprop="url" rel="index"><span itemprop="name">区块链技术研究</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          


          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Zcash的相关知识介绍"><a href="#1-Zcash的相关知识介绍" class="headerlink" title="1. Zcash的相关知识介绍"></a>1. Zcash的相关知识介绍</h1><h2 id="1-1-Zcash的工作原理"><a href="#1-1-Zcash的工作原理" class="headerlink" title="1.1 Zcash的工作原理"></a>1.1 Zcash的工作原理</h2><p>Zcash是一种从Bitcoin中分叉出来的代币, 其目的在于解决bitcoin中交易在执行过程中可以利用区块追踪交易记录的问题,进而使得交易难以追踪以提高匿名性.<br>Zcash中的地址有两种,一种叫做transparent address,简称t-address,这种地址以t开头. 另外一种地址叫做shielded address, 这种地址以z开头.Zcash中大概有如下4种交易类型,如下图所示:</p>
<center>

<img src="https://img-blog.csdnimg.cn/20190313141202670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">

</center>

<p>z-address 到z-address的转账称之为Private transactions, z-address 到t-address的转账称之为Deshielding transactions, t-address到z-address的转账叫做Shielded transactions, 而t-address到t-address的转账叫做transparent transactions. </p>
<ol>
<li><p><strong>t-to-t transaction</strong></p>
<p>两个t-address之间的交易, 和Bitcoin中的交易完全相同,交易双方的地址, 交易费, 交易金额都是公开并且可以追踪的.一个典型的示例如下:</p>
<p> &lt;/center&gt;<br> <img src="https://img-blog.csdnimg.cn/2019031314352632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">&lt;/center&gt;<br> 这笔交易中, 有一个输入,2个输出,输入和输出的地址都是t开头.</p>
</li>
<li><p><strong>t-to-z transaction</strong></p>
<p> t-to-z transaction中,可以叫做shielded transaction, 只能看到输入地址, 即以t开头的地址,交易费等信息, 但是输出的具体地址以及地址个数是未知的.<br> &lt;/center&gt;<br> <img src="https://img-blog.csdnimg.cn/20190313144006733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">&lt;/center&gt;</p>
<p> 这笔交易中,只有1个输入,输入代币总量以及交易费也是已知的,但是输出的地址以及输出地址的个数是未知的, 最终输入的其他ZEC流入了<strong>shielded pool</strong>中.</p>
</li>
<li><p><strong>z-to-t transaction</strong></p>
<p> z-to-t transaction,又叫做 deshielded transaction,即从shielded pool中的代币转出至某个特定的t-address中.<br> &lt;/center&gt;<br> <img src="https://img-blog.csdnimg.cn/20190313144615912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">&lt;/center&gt;</p>
<p> 上图中,交易的输入地址和输入地址的个数未知,但是知道输出地址的数量和具体信息,同时输出代币数和交易费用已知.</p>
</li>
<li><p><strong>z-to-z transaction</strong></p>
<p> z-address 到z-address的转账称之为Private transactions,从z-toz交易中只能得知交易费。但是交易地址、地址数量以及交易的ZEC数目都是未知的。<br> &lt;/center&gt;</p>
<pre><code> &lt;img src=&quot;https://img-blog.csdnimg.cn/20190313145010448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70&quot; &gt;&lt;/center&gt;
</code></pre><p> 这笔交易中，输入地址和输出地址的数量以及具体信息都是未知的，唯一能确定的是交易费用。z-to-z地址之间的转换，就相当于在shielded pool中进行持续转账。所有z-address中的ZEC就组成了shielded pool.</p>
</li>
</ol>
<h2 id="1-2-JoinSplits"><a href="#1-2-JoinSplits" class="headerlink" title="1.2 JoinSplits"></a>1.2 JoinSplits</h2><p>简单的理解, 从t-add 转入 z-addr的转账交易，即将ZEC转入到shielded pool中，因此叫做shielded交易，而从z-addr转到t-addr的交易， 即从shielded pool中转出ZEC, 因此叫做deshielded 交易, z-address之间的转账,则称之为private transaction.</p>
<p>从上述4中交易的介绍中, 可以观察发现,只有t-address和t-address之间的转账中没有JoinSplits, 而凡是涉及到z-addrress的交易,图中都会有一个JoinSplits的字段, JoinSplits字段中指定了交易中ZEC的来源和去向,以及其中的零知识证明,这个证明允许其他人在不揭露交易内容的前提下验证加密交易的真实性. 关于阅读本论文, 我们只需要知道这个就可以了. </p>
<p>更多关于零知识的证明,感兴趣可以点击<a href="https://z.cash/technology/zksnarks" target="_blank" rel="noopener">zk-SNARKs</a>以及如下几个链接.</p>
<ul>
<li><p>ZCash中的Transaction: <a href="https://z.cash/technology/#viewing-keys" target="_blank" rel="noopener">https://z.cash/technology/#viewing-keys</a> </p>
</li>
<li><p>ZCash中的Anatomy:  <a href="https://z.cash/blog/anatomy-of-zcash/" target="_blank" rel="noopener">https://z.cash/blog/anatomy-of-zcash/</a> * ZCash协议详解: <a href="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf" target="_blank" rel="noopener">https://github.com/zcash/zips/blob/master/protocol/protocol.pdf</a> (交易细节可以参看3.4节)</p>
</li>
<li><p>ZCash零知识证明: <a href="https://z.cash/zh/technology/zksnarks/" target="_blank" rel="noopener">https://z.cash/zh/technology/zksnarks/</a> </p>
</li>
</ul>
<h2 id="1-3-Zcash的主要参与者"><a href="#1-3-Zcash的主要参与者" class="headerlink" title="1.3 Zcash的主要参与者"></a>1.3 Zcash的主要参与者</h2><p>Zcash中的参与人主要有4类, </p>
<ul>
<li><p><strong>创始人(Founders)</strong>, </p>
</li>
<li><p><strong>矿工(Miners)</strong>, </p>
</li>
<li><p><strong>服务提供商(Services)</strong></p>
</li>
<li><p><strong>用户(Users).</strong></p>
</li>
</ul>
<p>在Zcash刚开始挖矿的4年中,每次矿工挖出一个区块时,都需要将25%的出块奖励转发给创始人团队, 一个区块的出块奖励为12.5ZEC, 创始人拿到2.5ZEC, 矿工拿到10ZEC. </p>
<h2 id="2-论文主要内容简要介绍"><a href="#2-论文主要内容简要介绍" class="headerlink" title="2. 论文主要内容简要介绍"></a>2. 论文主要内容简要介绍</h2><h3 id="2-1-主要研究方法和内容介绍"><a href="#2-1-主要研究方法和内容介绍" class="headerlink" title="2.1 主要研究方法和内容介绍"></a>2.1 主要研究方法和内容介绍</h3><p>这篇文章发表于2018年第27届USENIX Security Symposium会议,本论文非常深入的分析了Zcash的匿名程度,文章首先对Zcash区块链中的区块链信息进行了统计说明, 统计结果表明Zcash区块链中, 85%的交易都是transparent 交易, 而匿名的交易仅仅占比25%左右.<br>随后对Zcash中的交易(t-to-t, z-to-t, t-to-z, z-to-z), 使用5种启发式方法进行分析并尝试对其中的地址所对应的用户进行标记.通过文章中的启发式方法的分析,分别发现了创始人和矿工在进行z-to-t和t-to-z交易时的一些明显的特征, 利用这些特征识别出了创始人和矿工的隐匿的地址,同时也对其他一些黑客组织的地址进行了识别. 文章的5个启发式分析方法主要介绍如下:</p>
<ul>
<li><p><strong>启发式方法1: Zcash一笔交易中的多个输入地址都由同一个实体控制.</strong></p>
<ul>
<li><p>将Zcash区块链中每一个地址当做1个顶点, 同一笔交易中的多个输入地址之间用无向边连接, 以此完成了对Zcash中所有t-address的聚类, 总共得到560319个簇.</p>
</li>
<li><p>Zcash中的铸币交易, 一个区块产生12.5个ZEC, 其中10个归属矿工, 2.5个归属创始人, 因此每个区块的铸币交易中可以确定并且准确的标记出创始和矿工t-address.</p>
</li>
<li><p>分别从Top10的交易所购买Zcash, 随后在交易所的地址和自己Zcash的地址之间多次转账, 根据转账记录标记出交易所的地址.</p>
</li>
</ul>
</li>
<li><p><strong>启发式方法3: 任何交易值是250.0001ZEC的z-to-t转账交易时由创世团队发起</strong></p>
<ul>
<li><p>这是因为在文章作者在研究t-to-z的交易时, 发现创始团队比较有规律的往shielded pool转账, 每次转账249.9999ZEC, 这些t-to-z转账交易的时间间隔是6~10个区块. z-to-t的交易中, 有很多转账交易是价值250.0001ZEC的交易,这些交易也前后时间间隔是 6~10个区块,作者认为这是一种创世团队提取ZEC的一种自动转账脚本. </p>
</li>
<li><p>基于上述假设, 发现了创始人团队z-to-t转账中额外的75个地址, 而前面启发式方法1中发现了48个地址, 于是总共发现了123个创始人团队的地址. </p>
</li>
<li>创世人以为执行了t-to-z交易之后将自己的ZEC转入shielded pool, 随后从shielded pool中发起z-to-t的交易将ZEC转出, 结果使用了脚本, 于是作者利用启发式方法3建立了t-to-z 和z-to-t交易之间的联系,这是其重大意义所在. </li>
</ul>
</li>
<li><p><strong>启发式方法4: 如果1个z-to-t的交易中,输出地址超过100个,并且其中一个输出地址是一个已知的矿池地址, 那么认为其他输出地址也是矿工地址</strong></p>
<ul>
<li>这个假设的前提是因为在Zcash中, 矿工挖矿成功之后铸币交易的ZEC,必须先转入shield pool, 即先执行一个t-to-z交易, 随后从shield pool 转出时矿池将每个矿工的收益分别发送给矿工,剩余ZEC退回到矿池的地址.</li>
<li>通过上述的方法,确定了110918个矿工的地址, 启发式方法4能够将矿工的t-to-z和z-to-t转账交易中的t-address联系起来.</li>
</ul>
</li>
<li><p><strong>启发式方法5: 如果一笔t-to-z的交易, 交易值是V, 随后的一段时间内, 出现了一笔转账交易值也是V的z-to-t的交易, 则认为这笔交易时相关的</strong></p>
<ul>
<li>这个假设听起来很容易造成false positive, 但是实际上 总共有12841笔t-to-z和对应的z-to-t交易, 这些对应的交易都有着完全不同的交易值, 其中的9487笔交易精确到小数点后8位, 超过98.9%的交易精确到小数点后3位, 基于这个事实,基本可以认为这些交易是相关的.</li>
</ul>
</li>
</ul>
<p>注意, 上文没有介绍启发式方法2, 这是因为论文中仅仅介绍了该方法,但是考虑到实际的可靠性,并没有采用该方法. </p>
<h3 id="2-2-文章结论"><a href="#2-2-文章结论" class="headerlink" title="2.2 文章结论"></a>2.2 文章结论</h3><ul>
<li>通过上述启发式的方法, 作者能将shielded pool 中转账交易中69.1%的地址进行标记,这严重的降低了ZCash的匿名性功能. 大多数的用户并没有很好地使用ZCash的匿名性, 或者说与shield pool 进行交互进行匿名的方式仍然留下了线索从而被识别出来, 这减少了ZCash 中的匿名集的范围, 也严重的损害了其他用户的匿名性. 论文更多资料会议网址及资料<a href="https://www.usenix.org/conference/usenixsecurity18/presentation/kappos" target="_blank" rel="noopener">点击这里.</a></li>
</ul>
<h1 id="3-匿名性方面的其他研究"><a href="#3-匿名性方面的其他研究" class="headerlink" title="3. 匿名性方面的其他研究"></a>3. 匿名性方面的其他研究</h1><p>匿名性方面的研究工作, 目前的研究方向是两种, 一种是建立一个更好的匿名性的机制, 以增强区块链中的匿名性, 例如目前的CoinJoin,Mix混币技术,或者是建立新的Dash, Monero以及Zcash等匿名性更强的币种. 另外一方面的研究工作, 则是通过分析方法,指出目前区块链匿名性技术方面的不足.</p>
<ul>
<li><p>有一些学者致力于研究  <strong>混币(mix)</strong>  服务或者是建立新的币种的方法以提高匿名性, 或者致力于创建一种新的加密货币, 例如Dash, CoinJoin技术已经Monero和Zcash. 参考文献如下:</p>
<ul>
<li>E. Heilman, L. Alshenibr, F. Baldimtsi, A. Scafuro, and S. Goldberg. TumbleBit: an untrusted Bitcoin-compatible anonymous payment hub. In Proceedings of NDSS 2017, 2017</li>
<li>A. E. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacypreserving smart contracts. In 2016 IEEE Symposium on Security and Privacy, pages 839–858, San Jose, CA, USA, May 22–26, 2016. IEEE Computer Society Press</li>
<li>S. Meiklejohn and R. Mercer. Mobius: Trustless tumbling for  transaction privacy. Proceedings on Privacy Enhancing Technologies, 2018</li>
<li>T. Ruffing, P. Moreno-Sanchez, and A. Kate. CoinShuffle: Practical decentralized coin mixing for Bitcoin. In M. Kutylowski and J. Vaidya, editors, ESORICS 2014, Part II, volume 8713 of LNCS, pages 345–364, Wroclaw, Poland, Sept. 7–11, 2014. Springer, Heidelberg, Germany.</li>
<li>G. Maxwell. CoinJoin: Bitcoin privacy for the real world. bitcointalk.org/index.php?topic=279249, Aug. 2013.</li>
<li>Dash. <a href="https://www.dash.org" target="_blank" rel="noopener">https://www.dash.org</a>.</li>
<li>Monero. <a href="https://getmonero.org" target="_blank" rel="noopener">https://getmonero.org</a>.</li>
<li>Zcash. <a href="https://z.cash" target="_blank" rel="noopener">https://z.cash</a>.</li>
</ul>
</li>
<li><p>另外一些研究致力于通过一些方法检验加密货币的匿名性,指出其限制性.这些所有的研究都有共同的方案,就使用一些启发性的方法, 然后对所有的交易地址进行聚类, 再对聚类之后的地址进行标记以识别出这些地址的具体隶属信息. 目前已经有一些论文, 对Dash, Monero, CoinJoin以及Zcash的匿名性都进行了分析, 相关文献如下:</p>
</li>
</ul>
<ul>
<li><p>A. Kumar, C. Fischer, S. Tople, and P. Saxena. A traceability analysis of Monero’s blockchain. In Proceedings of ESORICS 2017, pages 153–173, 2017.</p>
</li>
<li><p>A. Miller, M. Moser, K. Lee, and A. Narayanan. An ¨ empirical analysis of linkability in the Monero blockchain. arXiv:1704.04299, 2017. <a href="https://arxiv.org/pdf/1704.04299.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1704.04299.pdf</a></p>
</li>
<li><p>P. Moreno-Sanchez, M. B. Zafar, and A. Kate. Listening to whispers of Ripple: Linking wallets and deanonymizing transactions in the Ripple network. Proceedings on Privacy Enhancing Technologies, 2016(4):436–453, 2016</p>
</li>
<li><p>P. Moreno-Sanchez, M. B. Zafar, and A. Kate. Listening to whispers of Ripple: Linking wallets and deanonymizing transactions in the Ripple network. Proceedings on Privacy Enhancing Technologies, 2016(4):436–453, 2016</p>
</li>
<li><p>J. Quesnelle. On the linkability of Zcash transactions. arXiv:1712.01210, 2017. <a href="https://arxiv.org/pdf/1712.01210.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1712.01210.pdf</a></p>
</li>
</ul>
<h1 id="4-思考"><a href="#4-思考" class="headerlink" title="4. 思考"></a>4. 思考</h1><ul>
<li><p>通过对这篇文章的阅读, 大概对区块链匿名性方面的研究有了一些初步的了解, “An Empirical Analysis of Anonymity in Zcash”这篇文章中的方法比较简单, 但是这些简单的方法应该是基于大量的研究分析工作得来的. 刚开始阅读完这篇文章的时候,我并没有认为这篇文章具有很大的贡献程度.</p>
</li>
<li><p>这篇文章能够发表在USENIX上,我觉得原因如下: </p>
<ol>
<li>文章的工作量很大, 对Zcash中所有的区块数据和交易都进行了大量的统计分析工作, 使得读者能对Zcash有一个非常直观的认知.</li>
<li>文章中使用了5种针对Zcash的启发式分析方法, 对t-address进行聚类, 随后进行标记, 然后建立tt-to-z和z-to-t这一匿名转账操作之间的联系, 找到了许多创始人和矿工的地址, 推理方法有理有据,分析比较到位.</li>
<li>该文章是第一个对Zcash的匿名性进行分析的文章, 指出了Zcash的弱点, 这就是对Zcash的匿名性的改进提供了方向.</li>
</ol>
</li>
</ul>
<ul>
<li>文章通过大量的分析和工作说明了一个问题, 即Zcash的匿名性并不仅仅是由零知识证明技术决定的, Zcash的用户在进行t-to-z交易和z-to-t交易中转换以隐藏自己身份的时候, 应该使用一种更加匿名的方式.一旦Zcash用户不能很好地隐匿自己, 其他用户的隐私性也会受到威胁.</li>
</ul>
<h1 id="5-对文章分析方法的详细阅读解析"><a href="#5-对文章分析方法的详细阅读解析" class="headerlink" title="5. 对文章分析方法的详细阅读解析"></a>5. 对文章分析方法的详细阅读解析</h1><h2 id="5-1-Zcash的统计信息"><a href="#5-1-Zcash的统计信息" class="headerlink" title="5.1 Zcash的统计信息"></a>5.1 Zcash的统计信息</h2><p>作者这里所说的所有区块统计信息,都是以2018年1月21日为止.</p>
<h3 id="5-1-1-区块生产信息"><a href="#5-1-1-区块生产信息" class="headerlink" title="5.1.1 区块生产信息"></a>5.1.1 区块生产信息</h3><p>作者使用zcashd客户端下载Zcash 区块链,将区块链载入Apache Spark中,随后使用pySpark包进行分析.截止2018年1月21日为止, 总共生产了258472个区块, 产生了31,06,043个ZEC, 其中矿工分得2,485,461, 创始人团队获得621,182 ZEC. 这里有个疑问是总共产生258472个区块,如果每个区块的reward为12.5, 那么总共应该产生3,230,900ZEC,但是实际上并没有这么多,这是因为最初的 20,000 个块的奖励很少，从第 1 个块开始到第 20,000 个块的奖励线性增加，在第 20,000 个块处奖励 12.5 个Zcash. 官方解释说这样做的目的是为防止早期的快速挖矿对 Zcash 系统造成伤害。 Zcash 系统每 2.5 分钟一个块，20,000 个块之后，每个块奖励 12.5 个Zcash。</p>
<h3 id="5-1-2-交易-Transactions"><a href="#5-1-2-交易-Transactions" class="headerlink" title="5.1.2 交易(Transactions)"></a>5.1.2 交易(Transactions)</h3><p>所有区块总共2,242,847笔交易, 交易具体分布信息如Table.1 所示.<br>    <center>
    <img src="https://img-blog.csdnimg.cn/20190313152246158.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
    </center><br>Table.1 中transparent指的是t-to-t交易的数量, Coingen指的是铸币交易, Deshielded指的是z-to-t的交易, shielded 指的是t-to-z交易.Mixed指的是混合交易,即一笔交易的输入或者输出中都包含t和z地址的交易. Private指的是z-to-z交易.<br>从表中显然可以看出, t-to-t交易仍然占有很大的比例,它与铸币交易总共占全部交易的85%, 与shielded pool有关的交易仅仅有335,630笔,总共占有14.96%的比例.</p>
<p>在Fig.2中,展示了随着时间的增长, Zcash区块链中各种交易所占的比例变化趋势,图中可以看出, Coingen, shielded以及deshielded交易都呈现出线性增长的情况,将在后续分析中分析其成因.</p>
<center>

<img src="https://img-blog.csdnimg.cn/20190313154343132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>
    Fig.3图揭示了随着时间增长,各种交易中涉及的ZEC比例变化趋势图. 从Fig.3 和Fig.2 的综合分析中, 可以看出与shielded pool的交易呈现出线性增长的趋势, 但是总ZEC的价值却呈现越来越小的比例, transparent交易的比例越来越高.

<center>
<img src="https://img-blog.csdnimg.cn/20190313154215741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="5-1-3-地址-Addresses-统计信息"><a href="#5-1-3-地址-Addresses-统计信息" class="headerlink" title="5.1.3 地址(Addresses)统计信息"></a>5.1.3 地址(Addresses)统计信息</h3><p>在所有的交易中, 有1,740,378个t-address, 其中8727笔交易时t-to-z trx, 另外330,780笔交易时z-to-t trx. 这两种交易不对称行的原因,是由于矿池的一些操作导致.矿池使用极少数量的地址收集block reward, 但是分配block reward时需要分别转给矿池中的每个矿工.由于shielded pool的存在, 无法探知到具体有多少z-address的存在.</p>
<p>Fig.4展示了shielded pool中ZEC随着时间增长的变化情况, 在图中有比较明显的震荡点, 而这是由于Zcash创始人的转账操作导致,后续会对这种情况给出更为具体的解释.截止到撰写本文的时间,<strong>shielded pool中总共有112, 235的ZEC.</strong></p>
<center>
    <img src="https://img-blog.csdnimg.cn/20190313155805593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>分别对t-address中的地址拥有ZEC的数量进行排序, 可以发现其中只有25%的地址中的ZEC数量大于0, 而在这25%的地址中, 其中前1%的地址拥有78%的ZEC. <strong>拥有ZEC最多的账户拥有118,257.75个ZEC, 这比整个shielded pool中的ZEC还要多!</strong></p>
<p>截止目前为止,论文作者主要介绍了ZCash中一些统计信息,使读者对整个ZCash有一个大概的了解, 下文中,对ZCash进行一些启发式的分析方法.</p>
<h1 id="6-T-Address-Clustering"><a href="#6-T-Address-Clustering" class="headerlink" title="6. T-Address Clustering"></a>6. T-Address Clustering</h1><p>因为Zcash中从t-address地址发出的的交易与Bitcoin中的交易类似, Bitcoin中对同一笔交易中的多个输入聚类的方法同样可以用来对Zcash中同一笔交易的多个t-address进行聚类. 因此,论文提出Heuristic 1, 具体解释如下:</p>
<h5 id="Heuristic-1-如果有多个t-address作为输入出现在同一笔交易中-无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易-我们都认为这些地址受同一个实体的控制"><a href="#Heuristic-1-如果有多个t-address作为输入出现在同一笔交易中-无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易-我们都认为这些地址受同一个实体的控制" class="headerlink" title="Heuristic 1: 如果有多个t-address作为输入出现在同一笔交易中,无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易, 我们都认为这些地址受同一个实体的控制."></a>Heuristic 1: 如果有多个t-address作为输入出现在同一笔交易中,无论这笔交易是t-to-z或者t-to-t抑或是Mixed交易, 我们都认为这些地址受同一个实体的控制.</h5><p>鉴于这种启发式的方法已经在Bitcoin中采用, 而Zcash又是Bitcoin的一个分叉,因此认为这个论断基本上是可信的.随后作者按照该方法对Zcash中的所有交易进行了聚类,假设交易中的每个t-address是一个节点, 则对同一笔交易中的多个输入用一条无向边链接, 随后得到聚类结果.经过聚类后得到560, 319个cluster, 其中97,539个cluster包含至少2个t-address.</p>
<p>这种启发式的方法可以发现由同一实体控制的多个地址,但是却不能有效的追踪常见的地址变换情况, 最常见的地址变换情况是一个sender使用地址Addr_A将ZEC发送给recipient,此外还有一部分的ZEC作为找零转到了自己的另外一个地址Addr_B上,随后如果sender仅仅将在一笔交易中心仅仅以Addr_B作为输入将剩余ZEC全部花出去时,上述启发式方法无法建立Addr_A和Addr_B之间实际上由同一实体控制的情况.</p>
<h5 id="Heuristic-2-如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address-代号t-addr-A-而第二个input地址-代号t-addr-B-同时又是唯一的一个output-t-address-那么-t-addr-B和t-addr-A隶属于同一实体控制"><a href="#Heuristic-2-如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address-代号t-addr-A-而第二个input地址-代号t-addr-B-同时又是唯一的一个output-t-address-那么-t-addr-B和t-addr-A隶属于同一实体控制" class="headerlink" title="Heuristic 2: 如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address(代号t_addr_A), 而第二个input地址(代号t_addr_B)同时又是唯一的一个output t-address,那么 t_addr_B和t_addr_A隶属于同一实体控制."></a>Heuristic 2: 如果在一笔交易的JoinSplit的input中有一个或者多个地址是t-address(代号t_addr_A), 而第二个input地址(代号t_addr_B)同时又是唯一的一个output t-address,那么 t_addr_B和t_addr_A隶属于同一实体控制.</h5><p>这个假设实在是,作者先到了这个假设,但是实际上由于Zcash的一个钱包—zcash4win的存在,有些用户会给钱包开发者一些费用,因此这个可能是个例外,于是作者并没有采用这个方法.</p>
<h2 id="6-1-Tagging-address-标记各种地址"><a href="#6-1-Tagging-address-标记各种地址" class="headerlink" title="6.1 Tagging address(标记各种地址)"></a>6.1 Tagging address(标记各种地址)</h2><h3 id="6-1-1-标记交易所的地址"><a href="#6-1-1-标记交易所的地址" class="headerlink" title="6.1.1 标记交易所的地址"></a>6.1.1 标记交易所的地址</h3><p>根据已有的clusters, 作者下一步目标是对这些cluster进行标记,以确定他们是Zcash的4类用户中的哪一类. 首先对交易所进行标记, 作者首先根据20家交易所的市场占有率,选出其中的top-10交易所, 随后分别从这些交易所中购入一些Zcash,然后在交易所的地址和自己注册的Zcash地址之间多次进行转账,每次转账的时候都对相应的交易所的地址进行标记.这样就可以确定相应交易所所在的cluster, 文章作者分别对每个cluster进行了标记,以每个簇中地址的个数从大到小排序,最大的簇标记为0, 与top-10交易所之间的交易次数,随后确定的交易所在的簇的编号, 具体结果如Table. 2所示.其中ShapShift是一家公司, 用户可以通过这个账户进行币种转换.</p>
<center>
<img src="https://img-blog.csdnimg.cn/20190313185947149.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="6-1-2-标记创始人和矿工的地址"><a href="#6-1-2-标记创始人和矿工的地址" class="headerlink" title="6.1.2  标记创始人和矿工的地址"></a>6.1.2  标记创始人和矿工的地址</h3><p>收集创始人已经公开的地址,同时从区块中标记矿工的地址, 验证矿工地址标记的正确性, 可以直接通过矿池网站查看矿池的为挖出区块的声明.</p>
<h3 id="6-1-3-结果"><a href="#6-1-3-结果" class="headerlink" title="6.1.3 结果"></a>6.1.3 结果</h3><h5 id="矿工和创始人"><a href="#矿工和创始人" class="headerlink" title="矿工和创始人"></a>矿工和创始人</h5><p>其中发现有一些矿工的地址是交易所的地址,这说明有些矿工直接将所属交易所的地址用来接收block reward, 这样为的是方便提现, 同时有一些创始人的地址也隶属于交易所.<br>Table2中可以看出ShapeShift的使用频率非常高,已经收到超过1.1M 的ZEC, 同时发送的ZEC几乎是等量的.与交易所不同，它的集群包含相对较少数量的矿工地址（54），这与其用作转移资金的方式相符，而不是将其存放在钱包中。<br>尽管矿池和创始人在Zcash中非常活跃,但是由于他们只使用少部分的地址, 因此他们的地址形成的簇不太大.</p>
<h5 id="公开的组织"><a href="#公开的组织" class="headerlink" title="公开的组织"></a>公开的组织</h5><p>另外,通过调查,发现了3个比较大的接收Zcash支付的组织:the Internet Archive, torservers.net以及Wikileaks. 其中torservers.net只通过z-address接收转账.因此无法识别出他们发起的交易. Wikileaks 也是只通过z-address接收转账.Internet Archive的31笔转账中总共转账17.3ZEC, 9笔交易是匿名的. Wikileaks的20笔转账交易全部是t-to-t交易,并且所有的地址单独成簇.</p>
<h1 id="7-与Shielded-Pool的交互"><a href="#7-与Shielded-Pool的交互" class="headerlink" title="7. 与Shielded Pool的交互"></a>7. 与Shielded Pool的交互</h1><p>这部分分析t-to-z和z-to-t交易.随着时间增长,总共有3,901,124的ZEC进入pool中,随后又有3,788,889的ZEC从pool中取出.Fig 5描述了这一情况, 基本上存储和取回的数量持平,并且呈现对称形式.这表明很多用户存入pool之后会很快的取回他们的ZEC.另外,图中有很明显的4处尖峰.第一处尖峰发生在2016年12月份,由1笔pool中取回7135ZEC的交易, 这笔ZEC分别转给15个t-address,这15个账户属于创始人. 第二处尖峰发生在2017年12月25日, 在242642个区块上,10,000ZECX分别转给10个t-address, 每个t-address收到了1,000ZEC, 目前这10个账户并没有进行任何交易.另外两次的t-to-z的尖峰是, 每个t-address都单独成一个簇,在后续中会说明与创始人有关.</p>
<center>
<img src="https://img-blog.csdnimg.cn/20190313194509493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>利用标记好的创始人信息和矿工的地址信息,分析这些包含创始人地址或者包含矿工地址的t-to-z转账交易, 得到Figure 6. 根据Figure 6可知矿工和创始人是往shielded pool 转账最多的人, 实际上占比可达76.7%. 而矿工占比达到63.7%, 这表明创始人并没有将很多ZEC放入pool中,毕竟创始人的ZEC是矿工的20%.</p>
<center>
<img src="https://img-blog.csdnimg.cn/20190313200026398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>转账最多的用户,往pool转入超过10,000ZEC, 转账情况如图Figure 7所示.从这图可以看出来, pool中存款的大户仍然是创始人和矿工.</p>
<center>
<img src="https://img-blog.csdnimg.cn/20190313200534852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h2 id="7-1-t-to-z和z-to-t交易之间建立联系"><a href="#7-1-t-to-z和z-to-t交易之间建立联系" class="headerlink" title="7.1 t-to-z和z-to-t交易之间建立联系"></a>7.1 t-to-z和z-to-t交易之间建立联系</h2><p>shield pool的最大作用是提供了一个匿名集, 用户通过t-to-z的转账之后再从z-to-t中提款,这样其他人就无法追踪提的款来自于哪里.但是如果把t-to-z和z-to-t这两种交易之间能够联系起来,这样在未来发生z-to-t的转账时可以把已确定名单的交易排除出去,这样就能够减小匿名集的大小.</p>
<p>最简单的方法是, 如果t-to-z中的t和z-to-t中的地址相同,那么就能排除一部分 shield pool 的匿名集合.于是实施这个想法的结果如图Figure 8a所示.实际上,通过这种方法,几乎没法将一些z-to-t交易和创始人的地址对应起来, 实际上,只能对应一部分矿工的地址.毕竟创始人不傻, 交易进入shield pool就是为了匿名,怎么可能再采用使用过的地址转出呢, 何况这个团队是以密码学为看家本领,所以不会犯这种错误,而只有对于矿工来说, 使用同样地址无所谓,因为对匿名性要求不高,能提款就好. 最终能与矿工地址对应起来的交易总共有49280笔,占所有z-to-t交易的13.3%.</p>
<center>
<img src="https://img-blog.csdnimg.cn/20190313205049137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="7-1-1-将z-to-t中创始人的t-address识别出来"><a href="#7-1-1-将z-to-t中创始人的t-address识别出来" class="headerlink" title="7.1.1 将z-to-t中创始人的t-address识别出来"></a>7.1.1 将z-to-t中创始人的t-address识别出来</h3><p>经过对创始人团队的地址分析,发现其中14个地址用于t-to-z的交易, 而其中每一笔t-to-z的交易每次转账都是249.9999ZEC, 这恰好是100个区块的奖励. 而另外只有5笔 249到251范围之间的t-to-z转账交易.基于这个特点,本来没法将t-to-z和z-to-t交易联系起来,但是这种模式给了作者灵感. 在所有的z-to-t交易中,没有发现249.9999的转账交易,但是发现了1953笔250.0001ZEC笔交易, 另外1969笔交易在249和251范围之间.于是作者检查了249.9999的t-to-z交易的频率,发现每笔交易之间间隔6~ 10个区块,再检查z-to-t的250.0001ZEC的交易时,发现1953中的1943笔交易的间隔大概是6~10个区块, t-to-z和z-to-t的交易,都像同一个模式, 这种模式的表现情况可以参看figure 9. </p>
<center><img src="https://img-blog.csdnimg.cn/20190313204433761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>基于Figure 9 的这种情况,作者大胆做出一个启发式方法:</p>
<h5 id="Heuristic-3-任何z-to-t的交易中-如果转出250-0001ZEC-那么这笔交易是由创始人发起的"><a href="#Heuristic-3-任何z-to-t的交易中-如果转出250-0001ZEC-那么这笔交易是由创始人发起的" class="headerlink" title="Heuristic 3. 任何z-to-t的交易中,如果转出250.0001ZEC, 那么这笔交易是由创始人发起的."></a>Heuristic 3. 任何z-to-t的交易中,如果转出250.0001ZEC, 那么这笔交易是由创始人发起的.</h5><p>通过运行这个方法, 作者通过z-to-t交易, 额外发现了75个创始人的t-address, 这和之前的48个地址加起来,总共是123个地址.通过这一波操作, 可以找到创始人的z-to-t的交易, 对比之前的figure 8a, 此时得到的Fugire 8b.</p>
<h3 id="7-1-2-将z-to-t中矿工的t-address识别出来"><a href="#7-1-2-将z-to-t中矿工的t-address识别出来" class="headerlink" title="7.1.2 将z-to-t中矿工的t-address识别出来"></a>7.1.2 将z-to-t中矿工的t-address识别出来</h3><p>Zcash协议规定铸币交易产生的ZEC,必须先进入shield pool, 然后才能更使用, 正因为此, 很多矿池或者个人矿工在铸币交易之后还需要将地址中的ZEC转入shield pool, 使用的时候再从shield pool中取回. 由于每个矿池网站会公布自己挖出的区块信息, 这样每个铸币交易时转账的地址就可以和矿池对应起来. 于是可以统计出每个矿池随着时间增长的情况下转往poll的ZEC值得变化情况.</p>
<center><img src="https://img-blog.csdnimg.cn/20190313210152616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>由于铸币交易存放在矿池的地址中, 矿池地址将ZEC转入pool之后把这些ZEC分发给自己的矿工, 每个矿池旗下都有很多个矿工,每个矿工都有自己的地址. 于是得出如下启发式方法.</p>
<h5 id="Heuristic-4-如果一个z-to-t的交易中有超过100个输出地址-只要其中1个地址属于已知的一个矿池地址-那么则认为这笔交易是矿池的withdrawl交易-同时对其他输出地址标记为矿工的地址"><a href="#Heuristic-4-如果一个z-to-t的交易中有超过100个输出地址-只要其中1个地址属于已知的一个矿池地址-那么则认为这笔交易是矿池的withdrawl交易-同时对其他输出地址标记为矿工的地址" class="headerlink" title="Heuristic 4. 如果一个z-to-t的交易中有超过100个输出地址,只要其中1个地址属于已知的一个矿池地址,那么则认为这笔交易是矿池的withdrawl交易, 同时对其他输出地址标记为矿工的地址."></a>Heuristic 4. 如果一个z-to-t的交易中有超过100个输出地址,只要其中1个地址属于已知的一个矿池地址,那么则认为这笔交易是矿池的withdrawl交易, 同时对其他输出地址标记为矿工的地址.</h5><p>启用该方法分析后, 最终得到在z-to-t标记中,将110918个地址标记为矿工地址, 最终得到的结果如图Fig.8c所示. top10矿池的t-to-z和z-to-t交易的信息如Table 4所示.</p>
<center><img src="https://img-blog.csdnimg.cn/20190313213901501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h3 id="7-1-3-识别其他实体交易"><a href="#7-1-3-识别其他实体交易" class="headerlink" title="7.1.3 识别其他实体交易"></a>7.1.3 识别其他实体交易</h3><h5 id="Heuristic-5-如果一个z-to-t的交易中包含价值v的转账-随后若干个区块时间间隔内的z-to-t的交易中的价值也是v-则认为这笔交易时round-trip-transaction"><a href="#Heuristic-5-如果一个z-to-t的交易中包含价值v的转账-随后若干个区块时间间隔内的z-to-t的交易中的价值也是v-则认为这笔交易时round-trip-transaction" class="headerlink" title="Heuristic 5. 如果一个z-to-t的交易中包含价值v的转账, 随后若干个区块时间间隔内的z-to-t的交易中的价值也是v, 则认为这笔交易时round-trip transaction."></a>Heuristic 5. 如果一个z-to-t的交易中包含价值v的转账, 随后若干个区块时间间隔内的z-to-t的交易中的价值也是v, 则认为这笔交易时round-trip transaction.</h5><p>这个假设看起来不那么靠谱,因为在若干个区块内t-to-z和z-to-t的两笔交易中的价值v相等的情况可能会很多,这种情况下没办法准确的将这些交易对应起来. 但是实际上经过分析发现,12,841笔不同面值的交易中, 其中9487笔交易的ZEC精确到了小数点后8位,其中的98.9%的交易,每笔交易的ZEC都精确到了小数点后3位.这些数据的特点,使得上述方法的实现成为了可能.</p>
<p>使用上述分析方法,最后识别出12841笔不同ZEC值的z-to-t和t-to-z的交易,转账总价值为 1,094,513.23684 ZEC, 其中97%的ZEC来自于矿工和创始人. 执行Heuristic 5中, 区块间隔分别设置为1~100,运行结果如图Figure 11所示. 当设置为10个区块间隔时, 可以关联到70%的z-to-t和t-to-z转账交易.</p>
<center><img src="https://img-blog.csdnimg.cn/2019031321532617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<h2 id="8-Shielded-Pool内部的交互"><a href="#8-Shielded-Pool内部的交互" class="headerlink" title="8.Shielded Pool内部的交互"></a>8.Shielded Pool内部的交互</h2><p>文中作者分析了6,934笔z-to-z的交易, 其中包括8,444个JoinSplits.  其中93%的z-to-z交易仅仅使用1个JoinSplit作为输入. 1个JoinSplit中最多包括2个shield output作为input,  这表明大部分的z-to-z交易时以最多2个shielded output作为input. 作者不太确定 是不是一小部分用户进行了多次的交易,或者是很多用户仅仅做一次交易.这样的根本问题在于, shielded pool中z-address的个数有多少个, 并且控制他们的实体到底有多少. 实际上发现Bitclub Pool中t-to-z交易总共有196笔, 但是z-to-z交易有1516笔,这说明要么Bitclub Pool 在t-to-z之后进行了很多z-to-z的交易, 要么说明t-to-z之后还有返回的找零. 然而实际上BitClub总共只有200个z-to-t交易, 所以前者的概率更大.</p>
<h2 id="9-案例分析-The-Shadow-Brokers"><a href="#9-案例分析-The-Shadow-Brokers" class="headerlink" title="9.案例分析:The Shadow Brokers"></a>9.案例分析:The Shadow Brokers</h2><p>The Shadow Brokers(TSB), 是一个2016年兴起的黑客组织, 主要贩售美国国家安全局(NSA)制作的软件, TSB起先值接收Bitcoin的转账, 随后开始接收Zcash的转账.</p>
<p>作者首先翻看了TSB的博客(目前该博客的网址貌似打不开了), 在2017年5月, 该组织宣称他们开始接收Zcash作为他们的服务费, 2017年6月~8月收取Zcash和Monero, 但是9月份以后只收Zcash. Table 5展示了该组织从5月份开始到10月份,总共收到的ZEC.</p>
<center><img src="https://img-blog.csdnimg.cn/20190313221915254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

<p>为了识别出有关该组织的t-to-z交易, 首先排除矿工和创始人存储的有关100, 200, 400, 500的t-to-z的交易, 所以对于TSB的客户,有下述两个假设:</p>
<ul>
<li>他们的ZEC不是来自于z-to-t交易, 并应该是来自t-to-t交易,因为可以从交易所购买币种.</li>
<li>他们不是经常使用ZEC的人,因此假设这个账户的交易次数在250以内.(250这个参数估计作者根据数据定的阈值)</li>
<li>改地址所属的较大的群在1个月以内存入pool不超过1 ZEC(老实说,这个假设我没看明白是啥意思)<br>最终得到24个疑似客户,结果如下Table 6所示.<center><img src="https://img-blog.csdnimg.cn/20190313225054124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Q0NjQxNDcwNDE1MmFiYw==,size_16,color_FFFFFF,t_70">
</center>

</li>
</ul>
<h2 id="10-结论"><a href="#10-结论" class="headerlink" title="10 结论"></a>10 结论</h2><p>该论文对Zcash的交易情况作了深入的分析, 尤其是对其匿名性保证进行了检验, 为了检验Zcash的匿名性,作者利用了众多启发式的方法以及之前对其他加密货币用过的经验分析方法. 论文研究结果表明大多数的用户并没有很好地使用ZCash的匿名性,或者说大多数的用户并没有很好地使用ZCash的匿名性, 与shield pool 进行交互进行匿名的方式仍然留下了线索从而被识别出来, 这减少了ZCash 中的匿名集的范围, 也严重的损害了其他用户的匿名性.</p>

          
        
      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar2.jpg" alt="博主">
            
              <p class="site-author-name" itemprop="name">博主</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/lastGod" title="GitHub &rarr; https://github.com/lastGod" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.zhihu.com/people/wen-ge-hua-49/activities" title="Zhihu &rarr; https://www.zhihu.com/people/wen-ge-hua-49/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>Zhihu</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.youtube.com/channel/UCBtnEPEpvAyEGXNarIPzqaA?view_as=subscriber" title="YouTube &rarr; https://www.youtube.com/channel/UCBtnEPEpvAyEGXNarIPzqaA?view_as=subscriber" rel="noopener" target="_blank"><i class="fa fa-fw fa-youtube"></i>YouTube</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://me.csdn.net/t46414704152abc" title="CSDN &rarr; https://me.csdn.net/t46414704152abc" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>CSDN</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://www.bilibili.com/video/av37065233" title="bilibili &rarr; https://www.bilibili.com/video/av37065233" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>bilibili</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://study.163.com/course/courseMain.htm?share=2&shareId=400000000626083&courseId=1006145002&_trace_c_p_k2_=2f085c5758434a769788a6c7a1c88e11" title="NetCloud &rarr; https://study.163.com/course/courseMain.htm?share=2&shareId=400000000626083&courseId=1006145002&_trace_c_p_k2_=2f085c5758434a769788a6c7a1c88e11" rel="noopener" target="_blank"><i class="fa fa-fw fa-globe"></i>NetCloud</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      

      

<!--背景音乐-->
<!--iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 src="//music.163.com/outchain/player?type=2&id=37856454&auto=1&height=66"></iframe> --> 
<!--<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=556319523&auto=1&height=66"></iframe> -->
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="86" src="//music.163.com/outchain/player?type=2&id=4341314&auto=1&height=66"></iframe>

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">博主</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>


<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!--注释本行<span id="busuanzi_container_site_pv" style='display:none'>-->
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>

<span id="busuanzi_container_site_uv" style="display:none">
    本站访问<span id="busuanzi_value_site_uv"></span>人次
</span>
</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  



  
  

  
  
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('Copy')
        }, 300)
      }).append(e)
    })
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

</body>
</html>
